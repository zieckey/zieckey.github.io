<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeG Blog</title>
    <link>http://blog.codeg.cn/</link>
    <description>Recent content on CodeG Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2015. All rights reserved.</copyright>
    <lastBuildDate>Sun, 28 May 2017 18:11:01 +0000</lastBuildDate>
    <atom:link href="http://blog.codeg.cn/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>手把手制作一个vcpkg的安装包及port file相关说明</title>
      <link>http://blog.codeg.cn/post/blog/2017-05-28-how-to-build-a-vcpkg/</link>
      <pubDate>Sun, 28 May 2017 18:11:01 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-05-28-how-to-build-a-vcpkg/</guid>
      <description>

&lt;h1 id=&#34;0-前言:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;0. 前言&lt;/h1&gt;

&lt;p&gt;Windows平台的程序包的依赖管理一直以来都是个大难题。之前有&lt;a href=&#34;https://www.nuget.org/&#34;&gt;NuGet&lt;/a&gt;，现在有&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;。
本文的重点是先介绍一下&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;的特性，然后以一个实际例子说明，说明如何创建一个&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装包。&lt;/p&gt;

&lt;h1 id=&#34;1-vcpkg-https-github-com-microsoft-vcpkg-简介:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;1. &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;简介&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;是为了在windows平台能够方便获取一个C或者C++库。当前还处于预览版状态。不过已经有很多常见的库了，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;openssl&lt;/li&gt;
&lt;li&gt;boost&lt;/li&gt;
&lt;li&gt;zlib&lt;/li&gt;
&lt;li&gt;glog&lt;/li&gt;
&lt;li&gt;libevent&lt;/li&gt;
&lt;li&gt;curl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等，很多知名的C/C++库都已经提供&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装包。&lt;/p&gt;

&lt;h1 id=&#34;2-vcpkg-https-github-com-microsoft-vcpkg-安装:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;2. &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装&lt;/h1&gt;

&lt;p&gt;首先，我们的windows系统必须安装有下列软件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Visual Studio 2015 Update 3 or&lt;/li&gt;
&lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;li&gt;CMake 3.8.0 or higher (note: downloaded automatically if not found)&lt;/li&gt;
&lt;li&gt;git.exe available in your path&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后，我们在windows命令行终端上运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;d:\git&amp;gt; git clone https://github.com/Microsoft/vcpkg
d:\git&amp;gt; cd vcpkg
d:\git\vcpkg&amp;gt; .\bootstrap-vcpkg.bat
d:\git\vcpkg&amp;gt; .\vcpkg integrate install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-使用-vcpkg-https-github-com-microsoft-vcpkg-获取c-c-库:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;3. 使用&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;获取C/C++库&lt;/h1&gt;

&lt;p&gt;使用&lt;code&gt;vcpkg --help&lt;/code&gt;命令查看联席帮助文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg --help
Commands:
  vcpkg search [pat]              Search for packages available to be built
  vcpkg install &amp;lt;pkg&amp;gt;...          Install a package
  vcpkg remove &amp;lt;pkg&amp;gt;...           Uninstall a package
  vcpkg remove --outdated         Uninstall all out-of-date packages
  vcpkg list                      List installed packages
  vcpkg update                    Display list of packages for updating
  vcpkg hash &amp;lt;file&amp;gt; [alg]         Hash a file by specific algorithm, default SHA512

  vcpkg integrate install         Make installed packages available user-wide. Requires admin privileges on first use
  vcpkg integrate remove          Remove user-wide integration
  vcpkg integrate project         Generate a referencing nuget package for individual VS project use

  vcpkg export &amp;lt;pkg&amp;gt;... [opt]...  Exports a package
  vcpkg edit &amp;lt;pkg&amp;gt;                Open up a port for editing (uses %EDITOR%, default &#39;code&#39;)
  vcpkg import &amp;lt;pkg&amp;gt;              Import a pre-built library
  vcpkg create &amp;lt;pkg&amp;gt; &amp;lt;url&amp;gt;
             [archivename]        Create a new package
  vcpkg owns &amp;lt;pat&amp;gt;                Search for files in installed packages
  vcpkg cache                     List cached compiled packages
  vcpkg version                   Display version information
  vcpkg contact                   Display contact information to send feedback

Options:
  --triplet &amp;lt;t&amp;gt;                   Specify the target architecture triplet.
                                  (default: %VCPKG_DEFAULT_TRIPLET%, see &#39;vcpkg help triplet&#39;)

  --vcpkg-root &amp;lt;path&amp;gt;             Specify the vcpkg root directory
                                  (default: %VCPKG_ROOT%)

For more help (including examples) see the accompanying README.md.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看到，很多有用的命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vcpkg search [pattern]

&lt;ul&gt;
&lt;li&gt;搜索一个C/C++库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vcpkg install [pkg]

&lt;ul&gt;
&lt;li&gt;安装一个C/C++库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;vcpkg remove [pkg]

&lt;ul&gt;
&lt;li&gt;卸载(删除)一个C/C++库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面举例，安装&lt;code&gt;curl&lt;/code&gt;这个常用的C语言写的网络库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg install curl
The following packages will be built and installed:
    curl:x86-windows
  * libssh2:x86-windows
Additional packages (*) will be installed to complete this operation.
Building package libssh2:x86-windows...
-- CURRENT_INSTALLED_DIR=D:/git/vcpkg/installed/x86-windows
-- DOWNLOADS=D:/git/vcpkg/downloads
-- CURRENT_PACKAGES_DIR=D:/git/vcpkg/packages/libssh2_x86-windows
-- CURRENT_BUILDTREES_DIR=D:/git/vcpkg/buildtrees/libssh2
-- CURRENT_PORT_DIR=D:/git/vcpkg/ports/libssh2/.
-- Downloading https://www.libssh2.org/download/libssh2-1.8.0.tar.gz...
-- Downloading https://www.libssh2.org/download/libssh2-1.8.0.tar.gz... OK
-- Testing integrity of downloaded file...
-- Testing integrity of downloaded file... OK
-- Extracting source D:/git/vcpkg/downloads/libssh2-1.8.0.tar.gz
-- Extracting done
-- Applying patch D:/git/vcpkg/ports/libssh2/0001-Fix-UWP.patch
-- Applying patch D:/git/vcpkg/ports/libssh2/0001-Fix-UWP.patch done
-- Configuring x86-windows-rel
-- Configuring x86-windows-rel done
-- Configuring x86-windows-dbg
-- Configuring x86-windows-dbg done
-- Package x86-windows-rel
-- Package x86-windows-rel done
-- Package x86-windows-dbg
-- Package x86-windows-dbg done
-- Installing: D:/git/vcpkg/packages/libssh2_x86-windows/share/libssh2/copyright
-- Performing post-build validation
-- Performing post-build validation done
Building package libssh2:x86-windows... done
Installing package libssh2:x86-windows...
Installing package libssh2:x86-windows... done
Building package curl:x86-windows...
-- CURRENT_INSTALLED_DIR=D:/git/vcpkg/installed/x86-windows
-- DOWNLOADS=D:/git/vcpkg/downloads
-- CURRENT_PACKAGES_DIR=D:/git/vcpkg/packages/curl_x86-windows
-- CURRENT_BUILDTREES_DIR=D:/git/vcpkg/buildtrees/curl
-- CURRENT_PORT_DIR=D:/git/vcpkg/ports/curl/.
-- Downloading https://github.com/curl/curl/archive/curl-7_51_0.tar.gz...
-- Downloading https://github.com/curl/curl/archive/curl-7_51_0.tar.gz... OK
-- Testing integrity of downloaded file...
-- Testing integrity of downloaded file... OK
-- Extracting source D:/git/vcpkg/downloads/curl-7.51.0.tar.gz
-- Extracting done
-- Applying patch D:/git/vcpkg/ports/curl/0001_cmake.patch
-- Applying patch D:/git/vcpkg/ports/curl/0001_cmake.patch done
-- Applying patch D:/git/vcpkg/ports/curl/0002_fix_uwp.patch
-- Applying patch D:/git/vcpkg/ports/curl/0002_fix_uwp.patch done
-- Configuring x86-windows-rel
-- Configuring x86-windows-rel done
-- Configuring x86-windows-dbg
-- Configuring x86-windows-dbg done
-- Package x86-windows-rel
-- Package x86-windows-rel done
-- Package x86-windows-dbg
-- Package x86-windows-dbg done
-- Installing: D:/git/vcpkg/packages/curl_x86-windows/share/curl/copyright
-- Performing post-build validation
-- Performing post-build validation done
Building package curl:x86-windows... done
Installing package curl:x86-windows...
Installing package curl:x86-windows... done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，安装&lt;code&gt;curl&lt;/code&gt;所需的依赖安装包&lt;code&gt;libssh2&lt;/code&gt;也被自动安装处理好了。这类似与Linux系统下面的&lt;code&gt;yum&lt;/code&gt;工具，自动处理rpm包的依赖关系，非常棒。&lt;/p&gt;

&lt;p&gt;安装x64版本时，只需要在包名后面追加&lt;code&gt;:x64-windows&lt;/code&gt;即可，例如 &lt;code&gt;curl:x64-windows&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg install curl:x64-windows
The following packages will be built and installed:
    curl:x64-windows
  * libssh2:x64-windows
Additional packages (*) will be installed to complete this operation.
Building package zlib:x64-windows...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-step-by-step-手把手教你如何制作一个-vcpkg-https-github-com-microsoft-vcpkg-安装包:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;4. Step by step 手把手教你如何制作一个&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装包&lt;/h1&gt;

&lt;h4 id=&#34;a-创建一个c库项目:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;a) 创建一个C库项目&lt;/h4&gt;

&lt;p&gt;这里我们直接创建项目 &lt;a href=&#34;https://github.com/zieckey/vcpkgdemo&#34;&gt;https://github.com/zieckey/vcpkgdemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后提交了一些简单的代码及 CMakeLists.txt。并打了一个tag 1.0。从而我们得到一个该项目源码的现在的地址 &lt;a href=&#34;https://github.com/zieckey/vcpkgdemo/archive/1.0.zip&#34;&gt;https://github.com/zieckey/vcpkgdemo/archive/1.0.zip&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;b-从源头开始创建一个-vcpkg-https-github-com-microsoft-vcpkg-安装包项目-bootstrap-with-create:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;b) 从源头开始创建一个&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装包项目：Bootstrap with create&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg create vcpkgdemo https://github.com/zieckey/vcpkgdemo/archive/1.0.zip vcpkgdemo-1.0.zip
-- Generated portfile: D:\git\vcpkg\ports\vcpkgdemo\portfile.cmake
-- Generated CONTROL: D:\git\vcpkg\ports\vcpkgdemo\CONTROL
-- To launch an editor for these new files, run
--     .\vcpkg edit vcpkgdemo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，在&lt;code&gt;D:\git\vcpkg\ports\&lt;/code&gt;目录下多出一个&lt;code&gt;vcpkgdemo&lt;/code&gt;目录，并且目录下有两个文件&lt;code&gt;portfile.cmake&lt;/code&gt;和&lt;code&gt;CONTROL&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;c-定制-control-文件:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;c) 定制&lt;code&gt;CONTROL&lt;/code&gt;文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CONTROL&lt;/code&gt;文件原始内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Source: vcpkgdemo
Version:
Description:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们修改为下面内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Source: vcpkgdemo
Version: 1.0
Description: A demo to show how to create a vcpkg package
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-定制-portfile-cmake-文件:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;d) 定制&lt;code&gt;portfile.cmake&lt;/code&gt;文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;portfile.cmake&lt;/code&gt;文件原始内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Common Ambient Variables:
#   CURRENT_BUILDTREES_DIR    = ${VCPKG_ROOT_DIR}\buildtrees\${PORT}
#   CURRENT_PACKAGES_DIR      = ${VCPKG_ROOT_DIR}\packages\${PORT}_${TARGET_TRIPLET}
#   CURRENT_PORT DIR          = ${VCPKG_ROOT_DIR}\ports\${PORT}
#   PORT                      = current port name (zlib, etc)
#   TARGET_TRIPLET            = current triplet (x86-windows, x64-windows-static, etc)
#   VCPKG_CRT_LINKAGE         = C runtime linkage type (static, dynamic)
#   VCPKG_LIBRARY_LINKAGE     = target library linkage type (static, dynamic)
#   VCPKG_ROOT_DIR            = &amp;lt;C:\path\to\current\vcpkg&amp;gt;
#   VCPKG_TARGET_ARCHITECTURE = target architecture (x64, x86, arm)
#

include(vcpkg_common_functions)
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/vcpkgdemo-1.0)
vcpkg_download_distfile(ARCHIVE
    URLS &amp;quot;https://github.com/zieckey/vcpkgdemo/archive/1.0.zip&amp;quot;
    FILENAME &amp;quot;vcpkgdemo-1.0.zip&amp;quot;
    SHA512 8805850856abdd39afdafa78dbd3a9e1d57d1a19a97579facf4571a0980799483574163e5f9a877a1fa38d541b7a0820c8ae7db61ae896803a8f89c5c22e386a
)
vcpkg_extract_source_archive(${ARCHIVE})

vcpkg_configure_cmake(
    SOURCE_PATH ${SOURCE_PATH}
    PREFER_NINJA # Disable this option if project cannot be built with Ninja
    # OPTIONS -DUSE_THIS_IN_ALL_BUILDS=1 -DUSE_THIS_TOO=2
    # OPTIONS_RELEASE -DOPTIMIZE=1
    # OPTIONS_DEBUG -DDEBUGGABLE=1
)

vcpkg_install_cmake()

# Handle copyright
#file(COPY ${SOURCE_PATH}/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo)
#file(RENAME ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo/LICENSE ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo/copyright)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将其修改为下面内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include(vcpkg_common_functions)
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/vcpkgdemo-1.0)
vcpkg_download_distfile(ARCHIVE
    URLS &amp;quot;https://github.com/zieckey/vcpkgdemo/archive/1.0.zip&amp;quot;
    FILENAME &amp;quot;vcpkgdemo-1.0.zip&amp;quot;
    SHA512 5b526b848c05d9b30eac8aede6c6c19591baf45e601c54ed6a0aa40ae3f11545d9648f332fb991f9540e44cfc3fc3ea6dd6db3b6c9d8e076b74af08e9ac69740
)

message(STATUS &amp;quot;Begin to extract files ...&amp;quot;)
vcpkg_extract_source_archive(${ARCHIVE})

message(STATUS &amp;quot;Building vcpkgdemo project ...&amp;quot;)

vcpkg_configure_cmake(
    SOURCE_PATH ${SOURCE_PATH}
    OPTIONS -DCMAKE_TOOLCHAIN_FILE=D:/git/vcpkg/scripts/buildsystems/vcpkg.cmake -DEVPP_VCPKG_BUILD=ON
)

vcpkg_install_cmake()
file(MAKE_DIRECTORY ${CURRENT_PACKAGES_DIR}/share)
file(MAKE_DIRECTORY ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo)

#remove duplicated files
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)

# remove not used cmake files
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/share )
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/lib/cmake )
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/lib/cmake )

# Handle copyright
file(COPY ${SOURCE_PATH}/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo)
file(RENAME ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo/LICENSE ${CURRENT_PACKAGES_DIR}/share/vcpkgdemo/copyright)

message(STATUS &amp;quot;Installing done&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-测试:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;e) 测试&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg install vcpkgdemo
The following packages will be built and installed:
    vcpkgdemo:x86-windows
Building package vcpkgdemo:x86-windows...
-- CURRENT_INSTALLED_DIR=D:/git/vcpkg/installed/x86-windows
-- DOWNLOADS=D:/git/vcpkg/downloads
-- CURRENT_PACKAGES_DIR=D:/git/vcpkg/packages/vcpkgdemo_x86-windows
-- CURRENT_BUILDTREES_DIR=D:/git/vcpkg/buildtrees/vcpkgdemo
-- CURRENT_PORT_DIR=D:/git/vcpkg/ports/vcpkgdemo/.
-- Using cached D:/git/vcpkg/downloads/vcpkgdemo-1.0.zip
-- Testing integrity of cached file...
-- Testing integrity of cached file... OK
-- Begin to extract files ...
-- Extracting source D:/git/vcpkg/downloads/vcpkgdemo-1.0.zip
-- Extracting done
-- Building vcpkgdemo project ...
-- Configuring x86-windows-rel
-- Configuring x86-windows-rel done
-- Configuring x86-windows-dbg
-- Configuring x86-windows-dbg done
-- Package x86-windows-rel
-- Package x86-windows-rel done
-- Package x86-windows-dbg
-- Package x86-windows-dbg done
-- Installing done
-- Performing post-build validation
-- Performing post-build validation done
Building package vcpkgdemo:x86-windows... done
Installing package vcpkgdemo:x86-windows...
Installing package vcpkgdemo:x86-windows... done
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;f-将-d-git-vcpkg-ports-vcpkgdemo-整个目录提交到-https-github-com-microsoft-vcpkg-https-github-com-microsoft-vcpkg:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;f) 将&lt;code&gt;D:\git\vcpkg\ports\vcpkgdemo&lt;/code&gt;整个目录提交到&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;https://github.com/Microsoft/vcpkg&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;为了让这个vcpkg包能够被其世界上任何他人使用，我们必须将port file提交到&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;https://github.com/Microsoft/vcpkg&lt;/a&gt;项目中。&lt;/p&gt;

&lt;p&gt;也就是我们需要发起一个Pull Request到&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;的官方github地址 &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;https://github.com/Microsoft/vcpkg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里不再累述。&lt;/p&gt;

&lt;h1 id=&#34;5-step-by-step-手把手教你如何制作一个-vcpkg-https-github-com-microsoft-vcpkg-安装包-实际案例:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;5. Step by step 手把手教你如何制作一个&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;安装包：实际案例&lt;/h1&gt;

&lt;p&gt;这里我们以&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;项目为例。&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;是一个基于&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;开发的现代化C++11高性能网络服务器，自带TCP/UDP/HTTP等协议的异步非阻塞式的服务器和客户端库。&lt;/p&gt;

&lt;h4 id=&#34;第1步-从源头开始创建一个项目-bootstrap-with-create:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;第1步：从源头开始创建一个项目：Bootstrap with create&lt;/h4&gt;

&lt;p&gt;首先，我们需要有一个网络上可供下载的安装包地址，在这里我们选择 &lt;a href=&#34;https://github.com/Qihoo360/evpp/archive/v0.5.0.zip&#34;&gt;https://github.com/Qihoo360/evpp/archive/v0.5.0.zip&lt;/a&gt;
然后，我们需要为项目取一个好记的名字，最好是小写字母，这里我们选择 &lt;code&gt;evpp&lt;/code&gt;
最后，使用&lt;code&gt;vcpkg create&lt;/code&gt;创建一个项目模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg create evpp https://github.com/Qihoo360/evpp/archive/v0.5.0.zip evpp-0.5.0.zip
-- Generated portfile: D:\git\vcpkg\ports\evpp\portfile.cmake
-- Generated CONTROL: D:\git\vcpkg\ports\evpp\CONTROL
-- To launch an editor for these new files, run
--     .\vcpkg edit evpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，在&lt;code&gt;D:\git\vcpkg\ports\&lt;/code&gt;目录下多出一个&lt;code&gt;evpp&lt;/code&gt;目录，并且目录下有两个文件&lt;code&gt;portfile.cmake&lt;/code&gt;和&lt;code&gt;CONTROL&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;第2步-定制-control-文件:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;第2步：定制&lt;code&gt;CONTROL&lt;/code&gt;文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CONTROL&lt;/code&gt;文件原始内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Source: evpp
Version:
Description:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们修改为下面内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Source: evpp
Version: 0.5.0
Description: A modern C++ network library based on libevent for developing high performance network services in TCP/UDP/HTTP protocols.
Build-Depends: glog, libevent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的依赖库写法，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;依赖两个项目 &lt;a href=&#34;https://github.com/google/glog&#34;&gt;glog&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;，所以写法是 &lt;code&gt;Build-Depends: glog, libevent&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;第3步-定制-portfile-cmake-文件:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;第3步：定制&lt;code&gt;portfile.cmake&lt;/code&gt;文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;portfile.cmake&lt;/code&gt;文件原始内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Common Ambient Variables:
#   CURRENT_BUILDTREES_DIR    = ${VCPKG_ROOT_DIR}\buildtrees\${PORT}
#   CURRENT_PACKAGES_DIR      = ${VCPKG_ROOT_DIR}\packages\${PORT}_${TARGET_TRIPLET}
#   CURRENT_PORT DIR          = ${VCPKG_ROOT_DIR}\ports\${PORT}
#   PORT                      = current port name (zlib, etc)
#   TARGET_TRIPLET            = current triplet (x86-windows, x64-windows-static, etc)
#   VCPKG_CRT_LINKAGE         = C runtime linkage type (static, dynamic)
#   VCPKG_LIBRARY_LINKAGE     = target library linkage type (static, dynamic)
#   VCPKG_ROOT_DIR            = &amp;lt;C:\path\to\current\vcpkg&amp;gt;
#   VCPKG_TARGET_ARCHITECTURE = target architecture (x64, x86, arm)
#

include(vcpkg_common_functions)
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/evpp-0.5.0)
vcpkg_download_distfile(ARCHIVE
    URLS &amp;quot;https://github.com/Qihoo360/evpp/archive/v0.5.0.zip&amp;quot;
    FILENAME &amp;quot;evpp-0.5.0.zip&amp;quot;
    SHA512 fce8ebfec8b22b137f827a886f9ef658d70e060cef3950600ac42136d87cdd9357d78897348ed1d1c112c5e04350626fb218b02cba190a2c2a6fb81136eb2d7d
)
vcpkg_extract_source_archive(${ARCHIVE})

vcpkg_configure_cmake(
    SOURCE_PATH ${SOURCE_PATH}
    PREFER_NINJA # Disable this option if project cannot be built with Ninja
    # OPTIONS -DUSE_THIS_IN_ALL_BUILDS=1 -DUSE_THIS_TOO=2
    # OPTIONS_RELEASE -DOPTIMIZE=1
    # OPTIONS_DEBUG -DDEBUGGABLE=1
)

vcpkg_install_cmake()

# Handle copyright
#file(COPY ${SOURCE_PATH}/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/evpp)
#file(RENAME ${CURRENT_PACKAGES_DIR}/share/evpp/LICENSE ${CURRENT_PACKAGES_DIR}/share/evpp/copyright)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将其修改为下面内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include(vcpkg_common_functions)

set(EVPP_VERSION 0.5.0)
set(EVPP_HASH fce8ebfec8b22b137f827a886f9ef658d70e060cef3950600ac42136d87cdd9357d78897348ed1d1c112c5e04350626fb218b02cba190a2c2a6fb81136eb2d7d)
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/evpp-${EVPP_VERSION})
vcpkg_download_distfile(ARCHIVE
    URLS &amp;quot;https://github.com/Qihoo360/evpp/archive/v${EVPP_VERSION}.zip&amp;quot;
    FILENAME &amp;quot;evpp-${EVPP_VERSION}.zip&amp;quot;
    SHA512 ${EVPP_HASH}
)


message(STATUS &amp;quot;Begin to extract files ...&amp;quot;)
vcpkg_extract_source_archive(${ARCHIVE})

message(STATUS &amp;quot;Building evpp project ...&amp;quot;)

vcpkg_configure_cmake(
    SOURCE_PATH ${SOURCE_PATH}
    OPTIONS -DCMAKE_TOOLCHAIN_FILE=D:/git/vcpkg/scripts/buildsystems/vcpkg.cmake -DEVPP_VCPKG_BUILD=ON
)

vcpkg_install_cmake()
file(MAKE_DIRECTORY ${CURRENT_PACKAGES_DIR}/share)
file(MAKE_DIRECTORY ${CURRENT_PACKAGES_DIR}/share/evpp)

#remove duplicated files
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)

# remove not used cmake files
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/share )
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/lib/cmake )
file(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/lib/cmake )

# Handle copyright
file(COPY ${SOURCE_PATH}/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/evpp)
file(RENAME ${CURRENT_PACKAGES_DIR}/share/evpp/LICENSE ${CURRENT_PACKAGES_DIR}/share/evpp/copyright)

message(STATUS &amp;quot;Installing done&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第4步-测试:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;第4步：测试&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;D:\git\vcpkg&amp;gt;.\vcpkg install evpp
The following packages will be built and installed:
    evpp:x86-windows
Building package evpp:x86-windows...
-- CURRENT_INSTALLED_DIR=D:/git/vcpkg/installed/x86-windows
-- DOWNLOADS=D:/git/vcpkg/downloads
-- CURRENT_PACKAGES_DIR=D:/git/vcpkg/packages/evpp_x86-windows
-- CURRENT_BUILDTREES_DIR=D:/git/vcpkg/buildtrees/evpp
-- CURRENT_PORT_DIR=D:/git/vcpkg/ports/evpp/.
-- Using cached D:/git/vcpkg/downloads/evpp-0.5.0.zip
-- Testing integrity of cached file...
-- Testing integrity of cached file... OK
-- Begin to extract files ...
-- Extracting done
-- Building evpp project ...
-- Configuring x86-windows-rel
-- Configuring x86-windows-rel done
-- Configuring x86-windows-dbg
-- Configuring x86-windows-dbg done
-- Package x86-windows-rel
-- Package x86-windows-rel done
-- Package x86-windows-dbg
-- Package x86-windows-dbg done
-- Installing done
-- Performing post-build validation
-- Performing post-build validation done
Building package evpp:x86-windows... done
Installing package evpp:x86-windows...
Installing package evpp:x86-windows... done
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第5步-将-d-git-vcpkg-ports-evpp-整个目录提交到-https-github-com-microsoft-vcpkg-https-github-com-microsoft-vcpkg:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;第5步：将&lt;code&gt;D:\git\vcpkg\ports\evpp&lt;/code&gt;整个目录提交到&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;https://github.com/Microsoft/vcpkg&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;也就是我们需要发起一个Pull Request到&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;的官方github地址 &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;https://github.com/Microsoft/vcpkg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里不再累述。&lt;/p&gt;

&lt;h1 id=&#34;6-最后:d5b1c64b04f5a3ca42b256b2911d82e8&#34;&gt;6. 最后&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;项目官网地址为：&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;https://github.com/Qihoo360/evpp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为&lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt;制作的安装包，已经提交Pull Request ：&lt;a href=&#34;https://github.com/Microsoft/vcpkg/pull/1177&#34;&gt;https://github.com/Microsoft/vcpkg/pull/1177&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zieckey/vcpkgdemo&#34;&gt;vcpkgdemo&lt;/a&gt;的原始代码请见 &lt;a href=&#34;https://github.com/zieckey/vcpkgdemo&#34;&gt;https://github.com/zieckey/vcpkgdemo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>evpp设计细节系列(1)：利用 enable_shared_from_this 实现一个自管理的定时器</title>
      <link>http://blog.codeg.cn/post/blog/2017-04-19-the-detail-design-of-evpp-invoke-timer/</link>
      <pubDate>Wed, 19 Apr 2017 10:11:01 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-04-19-the-detail-design-of-evpp-invoke-timer/</guid>
      <description>

&lt;h1 id=&#34;0-前言:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;0. 前言&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;https://github.com/Qihoo360/evpp&lt;/a&gt;是一个高性能的Reactor模式的现代化的C++11版本的高性能网络库。该项目中有一个&lt;code&gt;InvokeTimer&lt;/code&gt;对象，接口头文件详细代码请参见&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/invoke_timer.h&#34;&gt;https://github.com/Qihoo360/evpp/blob/master/evpp/invoke_timer.h&lt;/a&gt;。它是一个能自我管理的定时器类，可以将一个仿函数绑定到该定时器上，然后让该定时器自己管理并在预期的一段时间后执行该仿函数。&lt;/p&gt;

&lt;p&gt;现在我们复盘一下这个功能的实现细节和演化过程。&lt;/p&gt;

&lt;h1 id=&#34;1-基础代码:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;1. 基础代码&lt;/h1&gt;

&lt;p&gt;定时器原型声明可能是下面的样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class InvokeTimer {
public:
    InvokeTimer(struct event_base* evloop, double timeout_ms, const std::function&amp;lt;void()&amp;gt;&amp;amp; f);
    ~InvokeTimer();
    void Start();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是最基本的接口，可以设置一个仿函数，并设置一个过期时间，然后绑定到一个&lt;code&gt;event_base&lt;/code&gt;对象上，然后就可以期待过了一个预期的时间后，我们设置的仿函数被调用了。&lt;/p&gt;

&lt;p&gt;为了便于说明后续的多个版本的实现，我们先将基础的不变的代码说明一下。&lt;/p&gt;

&lt;p&gt;基础代码，我们采用&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;项目中的&lt;code&gt;TimerEventWatcher&lt;/code&gt;，详细实现在这里&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/event_watcher.h&#34;&gt;event_watcher.h&lt;/a&gt;和&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/event_watcher.cc&#34;&gt;event_watcher.cc&lt;/a&gt;。它是一个时间定时器观察者对象，可以观察一个时间事件。&lt;/p&gt;

&lt;p&gt;头文件&lt;code&gt;event_watcher.h&lt;/code&gt;定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#pragma once

#include &amp;lt;functional&amp;gt;

struct event;
struct event_base;

namespace recipes {

class EventWatcher {
public:
    typedef std::function&amp;lt;void()&amp;gt; Handler;
    virtual ~EventWatcher();
    bool Init();
    void Cancel();

    void SetCancelCallback(const Handler&amp;amp; cb);
    void ClearHandler() { handler_ = Handler(); }
protected:
    EventWatcher(struct event_base* evbase, const Handler&amp;amp; handler);
    bool Watch(double timeout_ms);
    void Close();
    void FreeEvent();

    virtual bool DoInit() = 0;
    virtual void DoClose() {}

protected:
    struct event* event_;
    struct event_base* evbase_;
    bool attached_;
    Handler handler_;
    Handler cancel_callback_;
};

class TimerEventWatcher : public EventWatcher {
public:
    TimerEventWatcher(struct event_base* evbase, const Handler&amp;amp; handler, double timeout_ms);

    bool AsyncWait();

private:
    virtual bool DoInit();
    static void HandlerFn(int fd, short which, void* v);
private:
    double timeout_ms_;
};

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现文件&lt;code&gt;event_watcher.cc&lt;/code&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;string.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

#include &amp;lt;event2/event.h&amp;gt;
#include &amp;lt;event2/event_struct.h&amp;gt;
#include &amp;lt;event2/event_compat.h&amp;gt;

#include &amp;lt;iostream&amp;gt;

#include &amp;quot;event_watcher.h&amp;quot;

namespace recipes {

EventWatcher::EventWatcher(struct event_base* evbase, const Handler&amp;amp; handler)
    : evbase_(evbase), attached_(false), handler_(handler) {
    event_ = new event;
    memset(event_, 0, sizeof(struct event));
}

EventWatcher::~EventWatcher() {
    FreeEvent();
    Close();
}

bool EventWatcher::Init() {
    if (!DoInit()) {
        goto failed;
    }

    ::event_base_set(evbase_, event_);
    return true;

failed:
    Close();
    return false;
}


void EventWatcher::Close() {
    DoClose();
}

bool EventWatcher::Watch(double timeout_ms) {
    struct timeval tv;
    struct timeval* timeoutval = nullptr;
    if (timeout_ms &amp;gt; 0) {
        tv.tv_sec = long(timeout_ms / 1000);
        tv.tv_usec = long(timeout_ms * 1000.0) % 1000;
        timeoutval = &amp;amp;tv;
    }

    if (attached_) {
        // When InvokerTimer::periodic_ == true, EventWatcher::Watch will be called many times
        // so we need to remove it from event_base before we add it into event_base
        if (event_del(event_) != 0) {
            std::cerr &amp;lt;&amp;lt; &amp;quot;event_del failed. fd=&amp;quot; &amp;lt;&amp;lt; this-&amp;gt;event_-&amp;gt;ev_fd &amp;lt;&amp;lt; &amp;quot; event_=&amp;quot; &amp;lt;&amp;lt; event_ &amp;lt;&amp;lt; std::endl;
            // TODO how to deal with it when failed?
        }
        attached_ = false;
    }

    assert(!attached_);
    if (event_add(event_, timeoutval) != 0) {
        std::cerr &amp;lt;&amp;lt; &amp;quot;event_add failed. fd=&amp;quot; &amp;lt;&amp;lt; this-&amp;gt;event_-&amp;gt;ev_fd &amp;lt;&amp;lt; &amp;quot; event_=&amp;quot; &amp;lt;&amp;lt; event_ &amp;lt;&amp;lt; std::endl;
        return false;
    }
    attached_ = true;
    return true;
}

void EventWatcher::FreeEvent() {
    if (event_) {
        if (attached_) {
            event_del(event_);
            attached_ = false;
        }

        delete (event_);
        event_ = nullptr;
    }
}

void EventWatcher::Cancel() {
    assert(event_);
    FreeEvent();

    if (cancel_callback_) {
        cancel_callback_();
        cancel_callback_ = Handler();
    }
}

void EventWatcher::SetCancelCallback(const Handler&amp;amp; cb) {
    cancel_callback_ = cb;
}


TimerEventWatcher::TimerEventWatcher(struct event_base* evbase,
                                     const Handler&amp;amp; handler,
                                     double timeout_ms)
    : EventWatcher(evbase, handler)
    , timeout_ms_(timeout_ms) {}

bool TimerEventWatcher::DoInit() {
    ::event_set(event_, -1, 0, TimerEventWatcher::HandlerFn, this);
    return true;
}

void TimerEventWatcher::HandlerFn(int /*fd*/, short /*which*/, void* v) {
    TimerEventWatcher* h = (TimerEventWatcher*)v;
    h-&amp;gt;handler_();
}

bool TimerEventWatcher::AsyncWait() {
    return Watch(timeout_ms_);
}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-一个最基本的实现-basic-01:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;2. 一个最基本的实现：basic-01&lt;/h1&gt;

&lt;p&gt;我们先尝试实现一个能满足最基本需求的定时器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;
// 头文件
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

struct event_base;

namespace recipes {

class TimerEventWatcher;
class InvokeTimer;

class InvokeTimer {
public:
    typedef std::function&amp;lt;void()&amp;gt; Functor;

    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f);
    ~InvokeTimer();

    void Start();

private:
    void OnTimerTriggered();

private:
    struct event_base* loop_;
    double timeout_ms_;
    Functor functor_;
    std::shared_ptr&amp;lt;TimerEventWatcher&amp;gt; timer_;
};

}



// 实现文件
#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;

#include &amp;lt;thread&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace recipes {

InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f)
    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

InvokeTimer::~InvokeTimer() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::~InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::Start() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
    timer_.reset(new TimerEventWatcher(loop_, std::bind(&amp;amp;InvokeTimer::OnTimerTriggered, this), timeout_ms_));
    timer_-&amp;gt;Init();
    timer_-&amp;gt;AsyncWait();
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start(AsyncWait) tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; timer=&amp;quot; &amp;lt;&amp;lt; timer_.get() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; timeout(ms)=&amp;quot; &amp;lt;&amp;lt; timeout_ms_ &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::OnTimerTriggered() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnTimerTriggered tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
    functor_();
    functor_ = Functor();
}

}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试main.cc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;
#include &amp;quot;winmain-inl.h&amp;quot;

#include &amp;lt;event2/event.h&amp;gt;

void Print() {
    std::cout &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; &amp;quot; hello world.&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    struct event_base* base = event_base_new();
    auto timer = new recipes::InvokeTimer(base, 1000.0, &amp;amp;Print);
    timer-&amp;gt;Start();
    event_base_dispatch(base);
    event_base_free(base);
    delete timer;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先创建一个&lt;code&gt;event_base&lt;/code&gt;对象，随后创建一个&lt;code&gt;InvokeTimer&lt;/code&gt;对象，随后让timer启动起来，即将timer注册到&lt;code&gt;event_base&lt;/code&gt;对象中，最后运行&lt;code&gt;event_base_dispatch(base)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面编译运行，结果是符合预期的：当timer的时间到期后，能顺利触发回调。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ls -l
total 80
-rw-rw-r-- 1 weizili weizili  2729 Apr 15 20:39 event_watcher.cc
-rw-rw-r-- 1 weizili weizili   996 Apr 15 20:39 event_watcher.h
-rw-rw-r-- 1 weizili weizili  1204 Apr 14 10:55 invoke_timer.cc
-rw-rw-r-- 1 weizili weizili   805 Apr 14 10:55 invoke_timer.h
-rw-rw-r-- 1 weizili weizili   374 Apr 14 10:55 main.cc
$ g++ -std=c++11 event_watcher.cc invoke_timer.cc main.cc -levent
$ ./a.out
InvokeTimer::InvokeTimer tid=139965845526336 this=0x7ffd2790f780
InvokeTimer::Start tid=139965845526336 this=0x7ffd2790f780
InvokeTimer::Start(AsyncWait) tid=139965845526336 timer=0x14504c0 this=0x7ffd2790f780 timeout(ms)=1000
InvokeTimer::OnTimerTriggered tid=139965845526336 this=0x7ffd2790f780
Print hello world.
InvokeTimer::~InvokeTimer tid=139965845526336 this=0x7ffd2790f780
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现方式，&lt;code&gt;InvokeTimer&lt;/code&gt;对象生命周期的管理是一个问题，它需要调用者自己管理。&lt;/p&gt;

&lt;h1 id=&#34;3-能够实现最基本自我管理-basic-02:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;3. 能够实现最基本自我管理：basic-02&lt;/h1&gt;

&lt;p&gt;为了实现&lt;code&gt;InvokeTimer&lt;/code&gt;对象生命周期的自我管理，其实就是调用者不需要关心&lt;code&gt;InvokeTimer&lt;/code&gt;对象的生命周期问题。可以设想一下，假如&lt;code&gt;InvokeTimer&lt;/code&gt;对象创建后，当定时时间一到，我们就调用其绑定的毁掉回函，然后&lt;code&gt;InvokeTimer&lt;/code&gt;对象自我销毁，是不是就可以实现自我管理了呢？嗯，这个可行。请看下面代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;
// 头文件

#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

struct event_base;

namespace recipes {

class TimerEventWatcher;
class InvokeTimer;

class InvokeTimer {
public:
    typedef std::function&amp;lt;void()&amp;gt; Functor;

    static InvokeTimer* Create(struct event_base* evloop,
                                 double timeout_ms,
                                 const Functor&amp;amp; f);

    ~InvokeTimer();

    void Start();

private:
    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f);
    void OnTimerTriggered();

private:
    struct event_base* loop_;
    double timeout_ms_;
    Functor functor_;
    std::shared_ptr&amp;lt;TimerEventWatcher&amp;gt; timer_;
};

}


// 实现文件

#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;

#include &amp;lt;thread&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace recipes {

InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f)
    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

InvokeTimer* InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f) {
    return new InvokeTimer(evloop, timeout_ms, f);
}

InvokeTimer::~InvokeTimer() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::~InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::Start() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
    timer_.reset(new TimerEventWatcher(loop_, std::bind(&amp;amp;InvokeTimer::OnTimerTriggered, this), timeout_ms_));
    timer_-&amp;gt;Init();
    timer_-&amp;gt;AsyncWait();
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start(AsyncWait) tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; timer=&amp;quot; &amp;lt;&amp;lt; timer_.get() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; timeout(ms)=&amp;quot; &amp;lt;&amp;lt; timeout_ms_ &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::OnTimerTriggered() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnTimerTriggered tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
    functor_();
    functor_ = Functor();
    delete this;
}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，上述实现中，为了实现自我销毁，我们必须调用 &lt;strong&gt;delete&lt;/strong&gt; ，这就注定了&lt;code&gt;InvokeTimer&lt;/code&gt;对象必须在堆上创建，因此我们隐藏了它的构造函数，然后用一个静态的 &lt;strong&gt;Create&lt;/strong&gt; 成员来创建&lt;code&gt;InvokeTimer&lt;/code&gt;对象的实例。&lt;/p&gt;

&lt;p&gt;相应的，&lt;code&gt;main.cc&lt;/code&gt;也做了一点点修改代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;
#include &amp;quot;winmain-inl.h&amp;quot;

#include &amp;lt;event2/event.h&amp;gt;

void Print() {
    std::cout &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; &amp;quot; hello world.&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    struct event_base* base = event_base_new();
    auto timer = recipes::InvokeTimer::Create(base, 1000.0, &amp;amp;Print);
    timer-&amp;gt;Start(); // 启动完成后，就不用关注该对象了
    event_base_dispatch(base);
    event_base_free(base);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现，就不需要上层调用者手工&lt;code&gt;delete&lt;/code&gt;这个&lt;code&gt;InvokeTimer&lt;/code&gt;对象的实例，从而达到&lt;code&gt;InvokeTimer&lt;/code&gt;对象自我管理的目的。&lt;/p&gt;

&lt;p&gt;下面编译运行，结果是符合预期的：当timer时间到期后，能顺利触发回调，并且&lt;code&gt;InvokeTimer&lt;/code&gt;对象也自动析构了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ls -l
total 80
-rw-rw-r-- 1 weizili weizili  2729 Apr 15 20:39 event_watcher.cc
-rw-rw-r-- 1 weizili weizili   996 Apr 15 20:39 event_watcher.h
-rw-rw-r-- 1 weizili weizili  1204 Apr 14 10:55 invoke_timer.cc
-rw-rw-r-- 1 weizili weizili   805 Apr 14 10:55 invoke_timer.h
-rw-rw-r-- 1 weizili weizili   374 Apr 14 10:55 main.cc
$ g++ -std=c++11 event_watcher.cc invoke_timer.cc main.cc -levent
$ ./a.out
InvokeTimer::InvokeTimer tid=139965845526336 this=0x7ffd2790f780
InvokeTimer::Start tid=139965845526336 this=0x7ffd2790f780
InvokeTimer::Start(AsyncWait) tid=139965845526336 timer=0x14504c0 this=0x7ffd2790f780 timeout(ms)=1000
InvokeTimer::OnTimerTriggered tid=139965845526336 this=0x7ffd2790f780
Print hello world.
InvokeTimer::~InvokeTimer tid=139965845526336 this=0x7ffd2790f780
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-如果要取消一个定时器怎么办-cancel-03:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;4. 如果要取消一个定时器怎么办：cancel-03&lt;/h1&gt;

&lt;p&gt;上面第2种实现方式，实现了定时器的自我管理，调用者不需要关心定时器的生命周期的管理问题。接下来，新的需求又来了，上层调用者说，在对外发起一个请求时，可以设置一个定时器来处理超时问题，但如果请求及时的回来了，我们得及时取消该定时器啊，这又如何处理呢？&lt;/p&gt;

&lt;p&gt;这就相当于要把上层调用者还得一直保留&lt;code&gt;InvokeTimer&lt;/code&gt;对象的实例，以便在需要的时候，提前取消掉该定时器。上层调用者保留这个指针，就会带来一定的风险，例如误用，当&lt;code&gt;InvokeTimer&lt;/code&gt;对象已经自动析构了，该该指针还继续存在于上层调用者那里。&lt;/p&gt;

&lt;p&gt;于是乎，智能指针&lt;code&gt;shared_ptr&lt;/code&gt;出场了，我们希望上层调用者看到的对象是以&lt;code&gt;shared_ptr&amp;lt;InvokeTimer&amp;gt;&lt;/code&gt;形式存在的，无论上层调用者是否保留这个&lt;code&gt;shared_ptr&amp;lt;InvokeTimer&amp;gt;&lt;/code&gt;对象，&lt;code&gt;InvokeTimer&lt;/code&gt;对象都能自我管理，也就是说，当上层调用者不保留&lt;code&gt;shared_ptr&amp;lt;InvokeTimer&amp;gt;&lt;/code&gt;对象时，&lt;code&gt;InvokeTimer&lt;/code&gt;对象要能自我管理。&lt;/p&gt;

&lt;p&gt;这里就必须让&lt;code&gt;InvokeTimer&lt;/code&gt;对象本身也要保存一份&lt;code&gt;shared_ptr&amp;lt;InvokeTimer&amp;gt;&lt;/code&gt;对象。为了实现这一技术，我们需要引入&lt;code&gt;enable_shared_from_this&lt;/code&gt;。关于&lt;code&gt;enable_shared_from_this&lt;/code&gt;的介绍，网络上已经有很多资料了，这里不多累述。我们直接上最终的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;
// 头文件

#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

struct event_base;

namespace recipes {

class TimerEventWatcher;
class InvokeTimer;

typedef std::shared_ptr&amp;lt;InvokeTimer&amp;gt; InvokeTimerPtr;

class InvokeTimer : public std::enable_shared_from_this&amp;lt;InvokeTimer&amp;gt; {
public:
    typedef std::function&amp;lt;void()&amp;gt; Functor;

    static InvokeTimerPtr Create(struct event_base* evloop,
                                 double timeout_ms,
                                 const Functor&amp;amp; f);

    ~InvokeTimer();

    void Start();

    void Cancel();

    void set_cancel_callback(const Functor&amp;amp; fn) {
        cancel_callback_ = fn;
    }
private:
    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f);
    void OnTimerTriggered();
    void OnCanceled();

private:
    struct event_base* loop_;
    double timeout_ms_;
    Functor functor_;
    Functor cancel_callback_;
    std::shared_ptr&amp;lt;TimerEventWatcher&amp;gt; timer_;
    std::shared_ptr&amp;lt;InvokeTimer&amp;gt; self_; // Hold myself
};

}


// 实现文件

#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;

#include &amp;lt;thread&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace recipes {

InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f)
    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

InvokeTimerPtr InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f) {
    InvokeTimerPtr it(new InvokeTimer(evloop, timeout_ms, f));
    it-&amp;gt;self_ = it;
    return it;
}

InvokeTimer::~InvokeTimer() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::~InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::Start() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; refcount=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; std::endl;
    timer_.reset(new TimerEventWatcher(loop_, std::bind(&amp;amp;InvokeTimer::OnTimerTriggered, shared_from_this()), timeout_ms_));
    timer_-&amp;gt;SetCancelCallback(std::bind(&amp;amp;InvokeTimer::OnCanceled, shared_from_this()));
    timer_-&amp;gt;Init();
    timer_-&amp;gt;AsyncWait();
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::Start(AsyncWait) tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; timer=&amp;quot; &amp;lt;&amp;lt; timer_.get() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; refcount=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; &amp;quot; periodic=&amp;quot; &amp;lt;&amp;lt; periodic_ &amp;lt;&amp;lt; &amp;quot; timeout(ms)=&amp;quot; &amp;lt;&amp;lt; timeout_ms_ &amp;lt;&amp;lt; std::endl;
}

void InvokeTimer::Cancel() {
    if (timer_) {
        timer_-&amp;gt;Cancel();
    }
}

void InvokeTimer::OnTimerTriggered() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnTimerTriggered tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; use_count=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; std::endl;
    functor_();
    functor_ = Functor();
    cancel_callback_ = Functor();
    timer_.reset();
    self_.reset();
}

void InvokeTimer::OnCanceled() {
    std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnCanceled tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; use_count=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; std::endl;
    if (cancel_callback_) {
        cancel_callback_();
        cancel_callback_ = Functor();
    }
    functor_ = Functor();
    timer_.reset();
    self_.reset();
}

}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应的，&lt;code&gt;main.cc&lt;/code&gt;也做了一点点修改代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;
#include &amp;quot;winmain-inl.h&amp;quot;

#include &amp;lt;event2/event.h&amp;gt;

void Print() {
    std::cout &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; &amp;quot; hello world.&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    struct event_base* base = event_base_new();
    auto timer = recipes::InvokeTimer::Create(base, 1000.0, &amp;amp;Print);
    timer-&amp;gt;Start(); // 启动完成后，就不用关注该对象了
    event_base_dispatch(base);
    event_base_free(base);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现，就不需要上层调用者手工&lt;code&gt;delete&lt;/code&gt;这个&lt;code&gt;InvokeTimer&lt;/code&gt;对象的实例，从而达到&lt;code&gt;InvokeTimer&lt;/code&gt;对象自我管理的目的。&lt;/p&gt;

&lt;p&gt;下面编译运行，结果是符合预期的：当timer时间到期后，能顺利触发回调，并且&lt;code&gt;InvokeTimer&lt;/code&gt;对象也自动析构了。&lt;/p&gt;

&lt;h1 id=&#34;5-实现一个周期性的定时器-periodic-04:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;5. 实现一个周期性的定时器：periodic-04&lt;/h1&gt;

&lt;p&gt;上述几个实现中，都是一次性的定时器任务。但是如果我们想实现一个周期性的定时器该如何实现呢？例如，我们有一个任务，需要每分钟做一次。&lt;/p&gt;

&lt;p&gt;其实，基于上述第三个版本的实现，可以很容易的实现周期性的定时器功能。只需要在回调函数中，继续调用&lt;code&gt;timer-&amp;gt;AsyncWait()&lt;/code&gt;即可。详细的修改情况如下。&lt;/p&gt;

&lt;p&gt;头文件 invoke_timer.h 改变：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;
@@ -18,7 +18,8 @@ public:

     static InvokeTimerPtr Create(struct event_base* evloop,
                                  double timeout_ms,
-                                 const Functor&amp;amp; f);
+                                 const Functor&amp;amp; f,
+                                 bool periodic);

     ~InvokeTimer();

@@ -30,7 +31,7 @@ public:
         cancel_callback_ = fn;
     }
 private:
-    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f);
+    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f, bool periodic);
     void OnTimerTriggered();
     void OnCanceled();

@@ -40,6 +41,7 @@ private:
     Functor functor_;
     Functor cancel_callback_;
     std::shared_ptr&amp;lt;TimerEventWatcher&amp;gt; timer_;
+    bool periodic_;
     std::shared_ptr&amp;lt;InvokeTimer&amp;gt; self_; // Hold myself
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现文件 invoke_timer.cc 改变：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;
 namespace recipes {

-InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f)
-    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
+InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f, bool periodic)
+    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f), periodic_(periodic) {
     std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::InvokeTimer tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; std::endl;
 }

-InvokeTimerPtr InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f) {
-    InvokeTimerPtr it(new InvokeTimer(evloop, timeout_ms, f));
+InvokeTimerPtr InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp;amp; f, bool periodic) {
+    InvokeTimerPtr it(new InvokeTimer(evloop, timeout_ms, f, periodic));
     it-&amp;gt;self_ = it;
     return it;
 }
@@ -27,7 +27,7 @@ void InvokeTimer::Start() {
     timer_-&amp;gt;SetCancelCallback(std::bind(&amp;amp;InvokeTimer::OnCanceled, shared_from_this()));
     timer_-&amp;gt;Init();
     timer_-&amp;gt;AsyncWait();
 }

 void InvokeTimer::Cancel() {
@@ -39,14 +39,20 @@ void InvokeTimer::Cancel() {
 void InvokeTimer::OnTimerTriggered() {
     std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnTimerTriggered tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; use_count=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; std::endl;
     functor_();
-    functor_ = Functor();
-    cancel_callback_ = Functor();
-    timer_.reset();
-    self_.reset();
+
+    if (periodic_) {
+        timer_-&amp;gt;AsyncWait();
+    } else {
+        functor_ = Functor();
+        cancel_callback_ = Functor();
+        timer_.reset();
+        self_.reset();
+    }
 }

 void InvokeTimer::OnCanceled() {
     std::cout &amp;lt;&amp;lt; &amp;quot;InvokeTimer::OnCanceled tid=&amp;quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &amp;quot; this=&amp;quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot; use_count=&amp;quot; &amp;lt;&amp;lt; self_.use_count() &amp;lt;&amp;lt; std::endl;
+    periodic_ = false;
     if (cancel_callback_) {
         cancel_callback_();
         cancel_callback_ = Functor();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main.cc测试示例代码也有所修改，具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;invoke_timer.h&amp;quot;
#include &amp;quot;event_watcher.h&amp;quot;
#include &amp;quot;winmain-inl.h&amp;quot;

#include &amp;lt;event2/event.h&amp;gt;

void Print() {
    std::cout &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; &amp;quot; hello world.&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    struct event_base* base = event_base_new();
    auto timer = recipes::InvokeTimer::Create(base, 1000.0, &amp;amp;Print, true);
    timer-&amp;gt;Start();
    timer.reset();
    event_base_dispatch(base);
    event_base_free(base);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该版本是最终的实现版本。相关代码都在[&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer]这里，为了便于演示，其不依赖[evpp]。&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer]这里，为了便于演示，其不依赖[evpp]。&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;6-最后:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;6. 最后&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;项目官网地址为：&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;https://github.com/Qihoo360/evpp&lt;/a&gt;
本文中的详细代码实现请参考 [&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer&lt;/a&gt;]&lt;/p&gt;

&lt;h1 id=&#34;7-evpp系列文章列表:4fb79b78c21aac4725aa913c264ba1ad&#34;&gt;7. evpp系列文章列表&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zieckey/article/details/69803011&#34;&gt;evpp性能测试（3）: 对无锁队列boost::lockfree::queue和moodycamel::ConcurrentQueue做一个性能对比测试&lt;/a&gt;
&lt;a href=&#34;http://blog.csdn.net/zieckey/article/details/69170619&#34;&gt;evpp性能测试（2）: 与Boost.Asio进行吞吐量对比测试&lt;/a&gt;
&lt;a href=&#34;http://blog.csdn.net/zieckey/article/details/63778715&#34;&gt;evpp性能测试（1）: 与muduo进行吞吐量测试&lt;/a&gt;
&lt;a href=&#34;http://blog.csdn.net/zieckey/article/details/63760757&#34;&gt;发布一个高性能的Reactor模式的C++网络库：evpp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer]:https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer]:https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于evpp的EventLoop实现来对无锁队列boost::lockfree::queue和moodycamel::ConcurrentQueue做一个性能测试对比</title>
      <link>http://blog.codeg.cn/post/blog/2017-04-09-the-benchmark-of-lockfree/</link>
      <pubDate>Sun, 09 Apr 2017 10:11:01 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-04-09-the-benchmark-of-lockfree/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_lockfree_vs_mutex_cn.md&#34;&gt;English version : The performance benchmark of &lt;code&gt;queue with std::mutex&lt;/code&gt; against &lt;code&gt;boost::lockfree::queue&lt;/code&gt; and &lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;brief:90274e2ef0997796a55625dfa35ad61a&#34;&gt;Brief&lt;/h3&gt;

&lt;p&gt;我们使用&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;https://github.com/Qihoo360/evpp&lt;/a&gt;项目中的&lt;code&gt;EventLoop::QueueInLoop(...)&lt;/code&gt;函数来做这个性能测试。我们通过该函数能够将一个仿函数执行体从一个线程调度到另一个线程中执行。这是一个典型的生产者和消费者问题。&lt;/p&gt;

&lt;p&gt;我们用一个队列来保存这种仿函数执行体。多个生产者线程向这个队列写入仿函数执行体，一个消费者线程从队列中取出仿函数执行体来执行。为了保证队列的线程安全问题，我们可以使用一个锁来保护这个队列，或者使用无锁队列机制来解决安全问题。&lt;code&gt;EventLoop::QueueInLoop(...)&lt;/code&gt;函数通过通定义实现了三种不同模式的跨线程交换数据的队列。&lt;/p&gt;

&lt;h3 id=&#34;测试对象:90274e2ef0997796a55625dfa35ad61a&#34;&gt;测试对象&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/archive/v0.3.2.zip&#34;&gt;evpp-v0.3.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EventLoop::QueueInLoop(...)&lt;/code&gt;函数内的队列的三种实现方式：

&lt;ul&gt;
&lt;li&gt;带锁的队列用&lt;code&gt;std::vector&lt;/code&gt;和&lt;code&gt;std::mutex&lt;/code&gt;来实现，具体的 gcc 版本为 4.8.2&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/&#34;&gt;boost::lockfree::queue from boost-1.53&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cameron314/concurrentqueue&#34;&gt;moodycamel::ConcurrentQueue&lt;/a&gt; with commit c54341183f8674c575913a65ef7c651ecce47243&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试环境:90274e2ef0997796a55625dfa35ad61a&#34;&gt;测试环境&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux CentOS 6.2, 2.6.32-220.7.1.el6.x86_64&lt;/li&gt;
&lt;li&gt;Intel&amp;reg; Xeon&amp;reg; CPU E5-2630 v2 @ 2.60GHz&lt;/li&gt;
&lt;li&gt;gcc version 4.8.2 20140120 (Red Hat 4.8.2-15) (GCC)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试方法:90274e2ef0997796a55625dfa35ad61a&#34;&gt;测试方法&lt;/h3&gt;

&lt;p&gt;测试代码请参考&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/benchmark/post_task/post_task6.cc&#34;&gt;https://github.com/Qihoo360/evpp/blob/master/benchmark/post_task/post_task6.cc&lt;/a&gt;. 在一个消费者线程中运行一个&lt;code&gt;EventLoop&lt;/code&gt;对象&lt;code&gt;loop_&lt;/code&gt;，多个生产者线程不停的调用&lt;code&gt;loop_-&amp;gt;QueueInLoop(...)&lt;/code&gt;方法将仿函数执行体放入到消费者的队列中让其消费（执行）。每个生产者线程放入一定总数（由运行参数指定）的仿函数执行体之后就停下来，等消费者线程完全消费完所有的仿函数执行体之后，程序退出，并记录开始和结束时间。&lt;/p&gt;

&lt;p&gt;为了便于大家阅读，现将相关代码的核心部分摘录如下。&lt;/p&gt;

&lt;p&gt;event_loop.h中定义了队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    std::shared_ptr&amp;lt;PipeEventWatcher&amp;gt; watcher_;
#ifdef H_HAVE_BOOST
    boost::lockfree::queue&amp;lt;Functor*&amp;gt;* pending_functors_;
#elif defined(H_HAVE_CAMERON314_CONCURRENTQUEUE)
    moodycamel::ConcurrentQueue&amp;lt;Functor&amp;gt;* pending_functors_;
#else
    std::mutex mutex_;
    std::vector&amp;lt;Functor&amp;gt;* pending_functors_; // @Guarded By mutex_
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;event_loop.cc中定义了&lt;code&gt;QueueInLoop(...)&lt;/code&gt;的具体实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void Init() {
    watcher_-&amp;gt;Watch(std::bind(&amp;amp;EventLoop::DoPendingFunctors, this));
}

void EventLoop::QueueInLoop(const Functor&amp;amp; cb) {
    {
#ifdef H_HAVE_BOOST
        auto f = new Functor(cb);
        while (!pending_functors_-&amp;gt;push(f)) {
        }
#elif defined(H_HAVE_CAMERON314_CONCURRENTQUEUE)
        while (!pending_functors_-&amp;gt;enqueue(cb)) {
        }
#else
        std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mutex_);
        pending_functors_-&amp;gt;emplace_back(cb);
#endif
    }

    watcher_-&amp;gt;Notify();
}

void EventLoop::DoPendingFunctors() {
#ifdef H_HAVE_BOOST
    Functor* f = nullptr;
    while (pending_functors_-&amp;gt;pop(f)) {
        (*f)();
        delete f;
    }
#elif defined(H_HAVE_CAMERON314_CONCURRENTQUEUE)
    Functor f;
    while (pending_functors_-&amp;gt;try_dequeue(f)) {
        f();
        --pending_functor_count_;
    }
#else
    std::vector&amp;lt;Functor&amp;gt; functors;
    {
        std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mutex_);
        notified_.store(false);
        pending_functors_-&amp;gt;swap(functors);
    }
    for (size_t i = 0; i &amp;lt; functors.size(); ++i) {
        functors[i]();
    }
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们进行了两种测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个生产者线程投递1000000个仿函数执行体到消费者线程中执行，统计总耗时。然后同样的方法我们反复测试10次&lt;/li&gt;
&lt;li&gt;生产者线程分别是2/4/6/8/12/16/20，每个线程投递1000000个仿函数执行体到消费者线程中执行，并统计总共耗时&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试结论:90274e2ef0997796a55625dfa35ad61a&#34;&gt;测试结论&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;当我们只有生产者和消费者都只有一个时，大多数测试结果表明&lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;的性能是最好的，大概比&lt;code&gt;queue with std::mutex&lt;/code&gt;高出&lt;strong&gt;10%~50%&lt;/strong&gt;左右的性能。&lt;code&gt;boost::lockfree::queue&lt;/code&gt;比&lt;code&gt;queue with std::mutex&lt;/code&gt;的性能只能高出一点点。由于我们的实现中，必须要求能够使用多生产者的写入，所以并没有测试boost中专门的单生产者单消费者的无锁队列&lt;code&gt;boost::lockfree::spsc_queue&lt;/code&gt;，在这种场景下，boost稍稍有些吃亏，但并不影响整体测试结果及结论。&lt;/li&gt;
&lt;li&gt;当我们有多个生产者线程和一个消费者线程时，&lt;code&gt;boost::lockfree::queue&lt;/code&gt;的性能比&lt;code&gt;queue with std::mutex&lt;/code&gt;高出&lt;strong&gt;75%~150%&lt;/strong&gt;左右。 &lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;的性能最好，大概比&lt;code&gt;boost::lockfree::queue&lt;/code&gt;高出&lt;strong&gt;25%~100%&lt;/strong&gt;，比&lt;code&gt;queue with std::mutex&lt;/code&gt;高出&lt;strong&gt;100%~500%&lt;/strong&gt;。当生产者线程越多，也就是锁冲突概率越大时，&lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;的性能优势体现得更加明显。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，上述对比测试结论，就我们的&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;项目中的&lt;code&gt;EventLoop&lt;/code&gt;的实现方式，我们推荐使用&lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;来实现跨线程的数据交换。&lt;/p&gt;

&lt;p&gt;更详细的测试数据，请参考下面的两个图表。&lt;/p&gt;

&lt;p&gt;纵轴是执行耗时，越低性能越高。&lt;/p&gt;

&lt;p&gt;图1，生产者和消费者都只有一个，横轴是测试的批次：
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/post_task/boost_lockfree-vs-mutex-1v1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图2，生产者线程有多个，横轴是生产者线程的个数，分别是2/4/6/8/12/16/20：
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/post_task/boost_lockfree-vs-mutex.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;其他的性能测试报告:90274e2ef0997796a55625dfa35ad61a&#34;&gt;其他的性能测试报告&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_ioevent_performance_vs_asio.md&#34;&gt;The IO Event performance benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; about &lt;strong&gt;20%~50%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_ping_pong_spend_time_vs_asio.md&#34;&gt;The ping-pong benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; about &lt;strong&gt;5%~20%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_throughput_vs_libevent.md&#34;&gt;The throughput benchmark against libevent2&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt; about &lt;strong&gt;17%~130%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_lockfree_vs_mutex.md&#34;&gt;The performance benchmark of &lt;code&gt;queue with std::mutex&lt;/code&gt; against &lt;code&gt;boost::lockfree::queue&lt;/code&gt; and &lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt;&lt;/a&gt; : &lt;code&gt;moodycamel::ConcurrentQueue&lt;/code&gt; is the best, the average is higher than &lt;code&gt;boost::lockfree::queue&lt;/code&gt; about &lt;strong&gt;25%~100%&lt;/strong&gt; and higher than &lt;code&gt;queue with std::mutex&lt;/code&gt; about &lt;strong&gt;100%~500%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_throughput_vs_asio.md&#34;&gt;The throughput benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_throughput_vs_asio_cn.md&#34;&gt;The throughput benchmark against Boost.Asio(中文)&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/docs/benchmark_throughput_vs_muduo_cn.md&#34;&gt;The throughput benchmark against muduo(中文)&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;h3 id=&#34;最后:90274e2ef0997796a55625dfa35ad61a&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;报告中的图表是使用&lt;a href=&#34;https://github.com/zieckey/gochart/&#34;&gt;gochart&lt;/a&gt;绘制的。&lt;/p&gt;

&lt;p&gt;非常感谢您的阅读。如果您有任何疑问，请随时在&lt;a href=&#34;https://github.com/Qihoo360/evpp/issues&#34;&gt;issue&lt;/a&gt;跟我们讨论。谢谢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>evpp与asio吞吐量对比</title>
      <link>http://blog.codeg.cn/post/blog/2017-04-04-the-throughput-benchmark-test-of-evpp-vs-asio/</link>
      <pubDate>Tue, 04 Apr 2017 18:13:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-04-04-the-throughput-benchmark-test-of-evpp-vs-asio/</guid>
      <description>

&lt;h3 id=&#34;简介:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.boost.org/&#34;&gt;Boost.Asio&lt;/a&gt;是用于网络和低层IO编程的跨平台C++库,为开发者提供了C++环境下稳定的异步编程模型。也是业内公认的优秀的C++网络库代表。一般来讲，其他的网络库的性能如果不能与&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;做一下全面的对比和评测，就不能令人信服。&lt;/p&gt;

&lt;p&gt;本次测试是参考陈硕的博客文章&lt;a href=&#34;http://blog.csdn.net/Solstice/article/details/5863411&#34;&gt;muduo 与 boost asio 吞吐量对比&lt;/a&gt;，该文章的结论是：&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;吞吐量平均比&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;高 &lt;strong&gt;15%&lt;/strong&gt; 以上。&lt;/p&gt;

&lt;p&gt;我们之前做的&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;与[moduo]吞吐量测试性能报告显示，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;与[moduo]吞吐量基本相当，各自都没有明显的优势。因此我们希望&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;在与&lt;a href=&#34;http://www.boost.org/&#34;&gt;boost&lt;/a&gt;的性能对比测试中能够占优。&lt;/p&gt;

&lt;h3 id=&#34;测试对象:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;测试对象&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/archive/v0.2.4.zip&#34;&gt;evpp-v0.2.4&lt;/a&gt; based on libevent-2.0.21&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio-1.10.8&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试环境:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;测试环境&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux CentOS 6.2, 2.6.32-220.7.1.el6.x86_64&lt;/li&gt;
&lt;li&gt;Intel&amp;reg; Xeon&amp;reg; CPU E5-2630 v2 @ 2.60GHz&lt;/li&gt;
&lt;li&gt;gcc version 4.8.2 20140120 (Red Hat 4.8.2-15) (GCC)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试方法:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;测试方法&lt;/h3&gt;

&lt;p&gt;依据 &lt;a href=&#34;http://www.boost.org/&#34;&gt;boost.asio&lt;/a&gt; 性能测试 &lt;a href=&#34;http://think-async.com/Asio/LinuxPerformanceImprovements&#34;&gt;http://think-async.com/Asio/LinuxPerformanceImprovements&lt;/a&gt; 的办法，用 ping pong 协议来测试吞吐量。&lt;/p&gt;

&lt;p&gt;简单地说，ping pong 协议是客户端和服务器都实现 echo 协议。当 TCP 连接建立时，客户端向服务器发送一些数据，服务器会 echo 回这些数据，然后客户端再 echo 回服务器。这些数据就会像乒乓球一样在客户端和服务器之间来回传送，直到有一方断开连接为止。这是用来测试吞吐量的常用办法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的测试代码在软件包内的路径为&lt;code&gt;benchmark/throughput/evpp&lt;/code&gt;，代码如&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/benchmark/throughput/evpp&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/benchmark/throughput/evpp&lt;/a&gt;所示。并使用 &lt;code&gt;tools&lt;/code&gt;目录下的&lt;code&gt;benchmark-build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;的测试代码直接使用陈硕&lt;a href=&#34;https://github.com/chenshuo/recipes&#34;&gt;recipes&lt;/a&gt;的实现，具体代码在这里&lt;a href=&#34;https://github.com/chenshuo/recipes/tree/master/pingpong/asio&#34;&gt;https://github.com/chenshuo/recipes/tree/master/pingpong/asio&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们做了下面两项测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单线程测试，测试并发连接数为 1/10/100/1000/10000 时，消息大小分别为 4096 8192 81920 409600 时的吞吐量&lt;/li&gt;
&lt;li&gt;多线程测试，并发连接数为 100 或 1000，服务器和客户端的线程数同时设为 2/3/4/6/8，ping pong 消息的大小为 4096 bytes。测试用的 shell 脚本可从&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的源码包中找到。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试结果数据:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;测试结果数据&lt;/h3&gt;

&lt;p&gt;最终测试结论如下：&lt;/p&gt;

&lt;p&gt;在吞吐量方面的性能总体来说，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;比&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;整体上明显更快，吞吐量高出大约20%~50%&lt;/p&gt;

&lt;h5 id=&#34;单线程测试数据:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;单线程测试数据&lt;/h5&gt;

&lt;p&gt;横轴是并发数。纵轴是吞吐量，越大越好。&lt;/p&gt;

&lt;p&gt;图表中的&lt;code&gt;evpp-1024&lt;/code&gt;表示消息大小为1024字节，其他以此类推，例如&lt;code&gt;evpp-4096&lt;/code&gt;表示消息大小为4096字节。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-from-chenshuo-recipes-1thread.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-from-chenshuo-recipes-1thread.png&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;多线程测试数据:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;多线程测试数据&lt;/h5&gt;

&lt;p&gt;横轴是线程个数。纵轴是吞吐量，越大越好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/multi-thread-evpp-vs-asio-from-chenshuo-recipes.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/multi-thread-evpp-vs-asio-from-chenshuo-recipes.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;分析:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;我们有些怀疑上述的测试数据中&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;的性能太过差，这当不起&lt;a href=&#34;http://www.boost.org/&#34;&gt;boost&lt;/a&gt;的大名。另外陈硕的博客&lt;a href=&#34;http://blog.csdn.net/Solstice/article/details/5863411&#34;&gt;muduo 与 boost asio 吞吐量对比&lt;/a&gt;中也提到一些想法：&lt;code&gt;猜测其主要原因是测试代码只使用了一个 io_service，如果改用“io_service per CPU”的话，性能应该有所提高&lt;/code&gt;。于是我们找到公司内对&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;非常熟悉的大牛胡大师操刀写了一个全新的测试程序，具体代码请见 &lt;a href=&#34;https://github.com/huyuguang/asio_benchmark&#34;&gt;https://github.com/huyuguang/asio_benchmark&lt;/a&gt;。 版本号：commits &lt;code&gt;21fc1357d59644400e72a164627c1be5327fbe3d&lt;/code&gt;，并用&lt;code&gt;client2/server2&lt;/code&gt;测试用例。 测试的脚本用 &lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/benchmark/throughput/asio/single_thread.sh&#34;&gt;single_thread.sh&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/benchmark/throughput/asio/multiple_thread.sh&#34;&gt;multiple_thread.sh&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;新的一轮测试下来，我们发现&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;的性能上来的，与[evpp] [moduo]等库相当。&lt;/p&gt;

&lt;p&gt;测试结论&lt;/p&gt;

&lt;h4 id=&#34;单线程场景:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;单线程场景&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;并发数为10000的测试中，&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;占优，平均比&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;高出 &lt;strong&gt;5%~10%&lt;/strong&gt; 左右&lt;/li&gt;
&lt;li&gt;在并发数为1，10，100，1000这四种场景下的测试中，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;性能更好，平均比&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;高出 &lt;strong&gt;10%~20%&lt;/strong&gt; 左右&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;详情请见下面图表,横轴是并发数。纵轴是吞吐量，越大越好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-1024.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-1024.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-2048.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-2048.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-4096.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-4096.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-8192.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-8192.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-16384.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-16384.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-81920.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-81920.png&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;多线程场景:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;多线程场景&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;在并发数为1000时，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;和&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;分阶段领先，各擅胜场&lt;/li&gt;
&lt;li&gt;在并发数100时，&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;比&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;整体更占优势，吞吐量高出 &lt;strong&gt;10%&lt;/strong&gt; 左右&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;详情请见下面图表,横轴是线程个数。纵轴是吞吐量，越大越好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-multi-thread-100connection-16384.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-multi-thread-100connection-16384.png&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-multi-thread-1000connection-16384.png&#34; alt=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-multi-thread-1000connection-16384.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;进一步分析:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;进一步分析&lt;/h3&gt;

&lt;p&gt;在陈硕的测试中，&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;的那个程序没有发挥出应有的性能，绝对与测试程序本身有关，而不是说&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;性能差，这从第二次测试结果可以看出来。&lt;/p&gt;

&lt;p&gt;在第二次测试中的多线程并发数为100的场景下，&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;性能比&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;高出 &lt;strong&gt;10%&lt;/strong&gt; 左右，一开始以为是&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;本身的性能在该场景下差一点，但后来仔细分析了胡大师写的这个测试代码 &lt;a href=&#34;https://github.com/huyuguang/asio_benchmark&#34;&gt;https://github.com/huyuguang/asio_benchmark&lt;/a&gt; 发现，这种ping pong测试中，正好能利用&lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt;的&lt;code&gt;Proactor&lt;/code&gt;的优势，他几乎没有内存分配，每次只读固定大小的数据然后发送出去，然后用通用的BUFFER来进行下一次读取操作。而&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;是&lt;code&gt;Reactor&lt;/code&gt;模式的网络库，其读取数据很可能不是固定的大小，这就涉及到了一些&lt;code&gt;evpp::Buffer&lt;/code&gt;内部的内存重分配问题，导致过多的内存分配、释放、拷贝等动作。&lt;/p&gt;

&lt;p&gt;因此，我们准备再做一轮测试，具体方法是模拟现实应用场景下消息长度不可能固定不变的，每个消息包括两部分，前面是HEADER，后面是BODY，HEADER中有BODY的长度，然后让BODY长度从1增长到100k大小，最后看看两者之间的性能对比数据。&lt;/p&gt;

&lt;h3 id=&#34;all-benchmark-reports:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;All benchmark reports&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_ioevent_performance_vs_asio.md&#34;&gt;The IO Event performance benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; about &lt;strong&gt;20%~50%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_ping_pong_spend_time_vs_asio.md&#34;&gt;The ping-pong benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; about &lt;strong&gt;5%~20%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_throughput_vs_libevent.md&#34;&gt;The throughput benchmark against libevent2&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; is higher than &lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt; about &lt;strong&gt;17%~130%&lt;/strong&gt; in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_lockfree_vs_mutex.md&#34;&gt;The performance benchmark of &lt;code&gt;queue with std::mutex&lt;/code&gt; against &lt;code&gt;boost::lockfree::queue&lt;/code&gt;&lt;/a&gt; : &lt;code&gt;boost::lockfree::queue&lt;/code&gt; is better, the average is higher than &lt;code&gt;queue with std::mutex&lt;/code&gt; about &lt;strong&gt;75%~150%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_throughput_vs_asio.md&#34;&gt;The throughput benchmark against Boost.Asio&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_throughput_vs_asio_cn.md&#34;&gt;The throughput benchmark against Boost.Asio(中文)&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;http://www.boost.org/&#34;&gt;asio&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;benchmark_throughput_vs_muduo_cn.md&#34;&gt;The throughput benchmark against muduo(中文)&lt;/a&gt; : &lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt; and &lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt; have the similar performance in this case&lt;/p&gt;

&lt;h3 id=&#34;最后:d59a8ce4788658b1cefbf683fbce157a&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;报告中的图表是使用&lt;a href=&#34;https://github.com/zieckey/gochart/&#34;&gt;gochart&lt;/a&gt;绘制的。&lt;/p&gt;

&lt;p&gt;非常感谢您的阅读。如果您有任何疑问，请随时在&lt;a href=&#34;https://github.com/Qihoo360/evpp/issues&#34;&gt;issue&lt;/a&gt;跟我们讨论。谢谢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>evpp与muduo吞吐量对比</title>
      <link>http://blog.codeg.cn/post/blog/2017-03-14-the-throughput-benchmark-test-of-evpp-vs-muduo/</link>
      <pubDate>Tue, 14 Mar 2017 18:13:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-03-14-the-throughput-benchmark-test-of-evpp-vs-muduo/</guid>
      <description>

&lt;h3 id=&#34;简介:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;是最近几年中国开源界里产生的优秀作品。它是由业内大牛陈硕实现的。详细介绍，请参考其博客介绍&lt;a href=&#34;http://blog.csdn.net/solstice/article/details/5848547&#34;&gt;http://blog.csdn.net/solstice/article/details/5848547&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本次测试是参考陈硕的博客文章&lt;a href=&#34;http://blog.csdn.net/solstice/article/details/5864889&#34;&gt;muduo与libevent2吞吐量对比&lt;/a&gt;，该文章的结论是：&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;吞吐量平均比&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;高 &lt;strong&gt;18%&lt;/strong&gt; 以上。&lt;/p&gt;

&lt;p&gt;由于&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;本身是基于&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;实现的，因此我们希望将&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;和&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;放到一起做一次全面的性能测试。本文是关于这两个库在吞吐量方面的测试。&lt;/p&gt;

&lt;h3 id=&#34;测试对象:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;测试对象&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/archive/v0.2.4.zip&#34;&gt;evpp-v0.2.4&lt;/a&gt; based on libevent-2.0.21&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chenshuo/muduo/archive/v1.0.9.zip&#34;&gt;muduo-v1.0.9&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试环境:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;测试环境&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux CentOS 6.2, 2.6.32-220.7.1.el6.x86_64&lt;/li&gt;
&lt;li&gt;Intel&amp;reg; Xeon&amp;reg; CPU E5-2630 v2 @ 2.60GHz&lt;/li&gt;
&lt;li&gt;gcc version 4.8.2 20140120 (Red Hat 4.8.2-15) (GCC)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试方法:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;测试方法&lt;/h3&gt;

&lt;p&gt;依据 boost.asio 性能测试 &lt;a href=&#34;http://think-async.com/Asio/LinuxPerformanceImprovements&#34;&gt;http://think-async.com/Asio/LinuxPerformanceImprovements&lt;/a&gt; 的办法，用 ping pong 协议来测试吞吐量。&lt;/p&gt;

&lt;p&gt;简单地说，ping pong 协议是客户端和服务器都实现 echo 协议。当 TCP 连接建立时，客户端向服务器发送一些数据，服务器会 echo 回这些数据，然后客户端再 echo 回服务器。这些数据就会像乒乓球一样在客户端和服务器之间来回传送，直到有一方断开连接为止。这是用来测试吞吐量的常用办法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;的测试代码在软件包内的路径为 &lt;code&gt;examples/pingpong/&lt;/code&gt;，代码如&lt;a href=&#34;https://github.com/chenshuo/muduo/tree/master/examples/pingpong&#34;&gt;https://github.com/chenshuo/muduo/tree/master/examples/pingpong&lt;/a&gt;所示。并使用&lt;code&gt;BUILD_TYPE=release ./build.sh&lt;/code&gt;方式编译&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;的优化版本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的测试代码在软件包内的路径为&lt;code&gt;benchmark/throughput/evpp&lt;/code&gt;，代码如&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/benchmark/throughput/evpp&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/benchmark/throughput/evpp&lt;/a&gt;所示。并使用 &lt;code&gt;tools&lt;/code&gt;目录下的&lt;code&gt;benchmark-build.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们做了下面两项测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单线程测试，测试并发连接数为 1/10/100/1000/10000 时，消息大小分别为 4096 8192 81920 409600 时的吞吐量&lt;/li&gt;
&lt;li&gt;多线程测试，并发连接数为 100 或 1000，服务器和客户端的线程数同时设为 2/3/4/6/8，ping pong 消息的大小为 16k bytes。测试用的 shell 脚本可从&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的源码包中找到。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;单线程测试结果数据:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;单线程测试结果数据&lt;/h3&gt;

&lt;p&gt;最终测试结论如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在吞吐量方面的性能总体来说，比较接近，各擅胜场&lt;/li&gt;
&lt;li&gt;在单个消息较大时（&amp;gt;81K)，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;比&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;整体上更快&lt;/li&gt;
&lt;li&gt;在单个消息不太大时，并发数小于1000时，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;占优&lt;/li&gt;
&lt;li&gt;在单个消息不太大时，并发数大于1000时，&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;占优&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;测试中，单个消息较大时，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;比&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;整体上更快的结论，我们认为是与&lt;code&gt;Buffer&lt;/code&gt;类的设计实现有关。&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的&lt;code&gt;Buffer&lt;/code&gt;类是自己人肉实现的内存管理，而&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;的&lt;code&gt;Buffer&lt;/code&gt;类的底层是用&lt;code&gt;std::vector&amp;lt;char&amp;gt;&lt;/code&gt;实现的，我们推测&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;的这个实现性能方面稍差。本次吞吐量测试中，主要的开销是网络IO事件的触发回调和数据读写，当消息size不太大时，网络IO的事件触发耗费CPU更多；当消息size较大时，数据的读写和拷贝占用更多CPU。当然这只是一个推测，后面如果有时间或大家感兴趣，可以自行验证两个库的&lt;code&gt;Buffer&lt;/code&gt;类的操作性能。&lt;/p&gt;

&lt;p&gt;这个测试结果进一步推断，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;比&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;更快（因为&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;吞吐量平均比&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;高 &lt;strong&gt;18%&lt;/strong&gt; 以上），表面上看不符合逻辑，因为&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;的底层就是&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;，但仔细分析发现，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;只是用了&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;核心的事件循环，并没有用&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent2&lt;/a&gt;中的&lt;code&gt;evbuffer&lt;/code&gt;相关类和函数来读写网络数据，而是借鉴&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;和&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;实现了自己独立的&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/buffer.h&#34;&gt;Buffer&lt;/a&gt;类来读写网络数据。&lt;/p&gt;

&lt;p&gt;下面是具体的测试数据和图表。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Message Size&lt;/th&gt;
&lt;th&gt;1 connection&lt;/th&gt;
&lt;th&gt;10 connections&lt;/th&gt;
&lt;th&gt;100 connections&lt;/th&gt;
&lt;th&gt;1000 connections&lt;/th&gt;
&lt;th&gt;10000 connections&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;evpp&lt;/td&gt;
&lt;td&gt;4096&lt;/td&gt;
&lt;td&gt;229.274&lt;/td&gt;
&lt;td&gt;631.611&lt;/td&gt;
&lt;td&gt;671.219&lt;/td&gt;
&lt;td&gt;495.566&lt;/td&gt;
&lt;td&gt;366.071&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;muduo&lt;/td&gt;
&lt;td&gt;4096&lt;/td&gt;
&lt;td&gt;222.117&lt;/td&gt;
&lt;td&gt;609.152&lt;/td&gt;
&lt;td&gt;631.119&lt;/td&gt;
&lt;td&gt;514.235&lt;/td&gt;
&lt;td&gt;365.959&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;evpp&lt;/td&gt;
&lt;td&gt;8192&lt;/td&gt;
&lt;td&gt;394.162&lt;/td&gt;
&lt;td&gt;1079.67&lt;/td&gt;
&lt;td&gt;1127.09&lt;/td&gt;
&lt;td&gt;786.706&lt;/td&gt;
&lt;td&gt;645.866&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;muduo&lt;/td&gt;
&lt;td&gt;8192&lt;/td&gt;
&lt;td&gt;393.683&lt;/td&gt;
&lt;td&gt;1064.43&lt;/td&gt;
&lt;td&gt;1103.02&lt;/td&gt;
&lt;td&gt;815.269&lt;/td&gt;
&lt;td&gt;670.503&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;evpp&lt;/td&gt;
&lt;td&gt;81920&lt;/td&gt;
&lt;td&gt;1565.22&lt;/td&gt;
&lt;td&gt;2079.77&lt;/td&gt;
&lt;td&gt;1464.16&lt;/td&gt;
&lt;td&gt;1323.09&lt;/td&gt;
&lt;td&gt;1297.18&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;muduo&lt;/td&gt;
&lt;td&gt;81920&lt;/td&gt;
&lt;td&gt;1567.959&lt;/td&gt;
&lt;td&gt;2180.467&lt;/td&gt;
&lt;td&gt;1432.009&lt;/td&gt;
&lt;td&gt;1267.181&lt;/td&gt;
&lt;td&gt;1159.278&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;evpp&lt;/td&gt;
&lt;td&gt;409600&lt;/td&gt;
&lt;td&gt;1950.79&lt;/td&gt;
&lt;td&gt;2363.68&lt;/td&gt;
&lt;td&gt;1528.97&lt;/td&gt;
&lt;td&gt;1290.17&lt;/td&gt;
&lt;td&gt;1039.96&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;muduo&lt;/td&gt;
&lt;td&gt;409600&lt;/td&gt;
&lt;td&gt;1887.057&lt;/td&gt;
&lt;td&gt;2213.813&lt;/td&gt;
&lt;td&gt;1305.899&lt;/td&gt;
&lt;td&gt;1131.383&lt;/td&gt;
&lt;td&gt;1043.612&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们用&lt;a href=&#34;https://github.com/zieckey/gochart&#34;&gt;https://github.com/zieckey/gochart&lt;/a&gt;这个图表绘制工具将上述数据绘制为图表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/1thread-4096-evpp-vs-muduo.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/1thread-8192-evpp-vs-muduo.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/1thread-81920-evpp-vs-muduo.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/1thread-409600-evpp-vs-muduo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;多线程测试结果:251aeffb3a5bb5eef7cdbb7cd5914ca7&#34;&gt;多线程测试结果&lt;/h3&gt;

&lt;p&gt;测试结论如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在多线程场景下，&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;和&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;两个库在吞吐量方面，的性能整体上来看没有明显区别，分阶段分别领先&lt;/li&gt;
&lt;li&gt;100并发连接比1000并发连接测试，两个库的吞吐量都明显的高得多&lt;/li&gt;
&lt;li&gt;在100并发连接测试下，随着线程数的增长，吞吐量基本上是线性增长。&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;库在中段领先于&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;，但在前期和后期又弱于&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在1000并发连接测试下，随着线程数的增长，前期基本上是线性增长，后期增长乏力。&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;库这方面表现尤其明显&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/multi-thread-evpp-vs-muduo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>发布一个高性能的Reactor模式的C&#43;&#43;网络库：evpp</title>
      <link>http://blog.codeg.cn/post/blog/2017-03-13-release-a-high-performance-C&#43;&#43;11-network-library/</link>
      <pubDate>Mon, 13 Mar 2017 18:13:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2017-03-13-release-a-high-performance-C&#43;&#43;11-network-library/</guid>
      <description>

&lt;h2 id=&#34;简介:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;是一个基于&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;开发的现代化的支持C++11特性的高性能网络库，自带TCP/UDP/HTTP等协议的异步非阻塞式的服务器和客户端库。&lt;/p&gt;

&lt;h2 id=&#34;特性:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;特性&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;现代版的C++11接口&lt;/li&gt;
&lt;li&gt;非阻塞异步接口都是C++11的functional/bind形式的回调仿函数（不是&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;中的C风格的函数指针）&lt;/li&gt;
&lt;li&gt;非阻塞纯异步多线程TCP服务器/客户端&lt;/li&gt;
&lt;li&gt;非阻塞纯异步多线程HTTP服务器/客户端&lt;/li&gt;
&lt;li&gt;非阻塞纯异步多线程UDP服务器&lt;/li&gt;
&lt;li&gt;支持多进程模式&lt;/li&gt;
&lt;li&gt;优秀的跨平台特性和高性能（继承自&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;的优点）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外，基于该库之上，还提供两个附带的应用层协议库：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;evmc&lt;/code&gt; ：一个纯异步非阻塞式的&lt;code&gt;memcached&lt;/code&gt;的C++客户端库，支持&lt;code&gt;membase&lt;/code&gt;集群模式。该库已经用于生产环境，每天发起1000多&lt;strong&gt;亿&lt;/strong&gt;次memcache查询请求。详情请见：&lt;a href=&#34;http://blog.codeg.cn/apps/evmc/readme.md&#34;&gt;evmc readme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evnsq&lt;/code&gt; ： 一个纯异步非阻塞式的&lt;code&gt;NSQ&lt;/code&gt;的C++客户端库，支持消费者、生产者、服务发现等特性。该库已经用于生产环境，每天生产200多&lt;strong&gt;亿&lt;/strong&gt;条日志消息。详情请见：&lt;a href=&#34;http://blog.codeg.cn/apps/evnsq/readme.md&#34;&gt;evnsq readme&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将来还会推出&lt;code&gt;redis&lt;/code&gt;的客户端库。&lt;/p&gt;

&lt;h2 id=&#34;项目由来:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;项目由来&lt;/h2&gt;

&lt;p&gt;我们开发小组负责的业务需要用到TCP协议来建设长连接网关服务和一些其他的一些基于TCP的短连接服务，在调研开源项目的过程中，没有发现一个合适的库来满足我们要求。结合我们自身的业务情况，理想中的C++网络库应具备一下几个特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接口简单易用，最好是C++接口&lt;/li&gt;
&lt;li&gt;多线程，也能支持多进程&lt;/li&gt;
&lt;li&gt;最好是基于&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;实现（因为现有的历史遗留框架、基础库等是依赖&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;），这样能很方便嵌入&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;的事件循环，否则改动较大或者集成起来的程序可能会有很多跨线程的调用（这些会带来编程的复杂性以及跨线程锁带来的性能下降）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于这些需求，可供选择的不多，所以我们只能自己开发一个。开发过程中，接口设计方面基本上大部分是参考&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;项目来设计和实现的，当然也做了一些取舍和增改；同时也大量借鉴了&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;的一些设计哲学和思想。下面举几个小例子来说明一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Duration&lt;/code&gt; ： 这是一个时间区间相关的类，自带时间单位信息，参考了&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;项目中的&lt;code&gt;Duration&lt;/code&gt;实现。我们在其他项目中见到太多的时间是不带单位的，例如&lt;code&gt;timeout&lt;/code&gt;，到底是秒、毫秒还是微秒？需要看文档说明或具体实现，好一点的设计会将单位带在变量名中，例如&lt;code&gt;timeout_ms&lt;/code&gt;，但还是没有&lt;code&gt;Duration&lt;/code&gt;这种独立的类好。目前C++11中也有类似的实现&lt;code&gt;std::chrono::duration&lt;/code&gt;，但稍显复杂，没有咱们这个借鉴&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;实现的版本来的简单明了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buffer&lt;/code&gt; ： 这是一个缓冲区类，融合了&lt;code&gt;muduo&lt;/code&gt;和&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;两个项目中相关类的设计和实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http::Server&lt;/code&gt; : 这是一个http服务器类，自带线程池，它的事件循环和工作线程调度，完全是线程安全的，业务层不用太多关心跨线程调用问题。同时，还将http服务器的核心功能单独抽取出来形成&lt;code&gt;http::Service&lt;/code&gt;类，是一个可嵌入型的服务器类，可以嵌入到已有的&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;事件循环中&lt;/li&gt;
&lt;li&gt;网络地址的表达就仅仅使用&lt;code&gt;&amp;quot;ip:port&amp;quot;&lt;/code&gt;这种形式字符串表示，就是参考&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;的设计&lt;/li&gt;
&lt;li&gt;&lt;code&gt;httpc::ConnPool&lt;/code&gt;是一个http的客户端连接池库，设计上尽量考虑高性能和复用。以后基于此还可以增加负载均衡和故障转移等特性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，我们实现过程中极其重视线程安全问题，一个事件相关的资源必须在其所属的&lt;code&gt;EventLoop&lt;/code&gt;（每个&lt;code&gt;EventLoop&lt;/code&gt;绑定一个线程）中初始化和析构释放，这样我们能最大限度的减少出错的可能。为了达到这个目标我们重载&lt;code&gt;event_add&lt;/code&gt;和&lt;code&gt;event_del&lt;/code&gt;等函数，每一次调用&lt;code&gt;event_add&lt;/code&gt;，就在对应的线程私有数据中记录该对象，在调用&lt;code&gt;event_del&lt;/code&gt;时，检查之前该线程私有数据中是否拥有该对象，然后在整个程序退出前，再完整的检查所有线程的私有数据，看看是否仍然有对象没有析构释放。具体实现稍有区别，详细代码实现可以参考 &lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/inner_pre.cc#L46~L87&#34;&gt;https://github.com/Qihoo360/evpp/blob/master/evpp/inner_pre.cc#L46~L87&lt;/a&gt;。我们如此苛刻的追求线程安全，只是为了让一个程序能&lt;strong&gt;安静的平稳的退出或Reload&lt;/strong&gt;，因为我们深刻的理解“编写永远运行的系统，和编写运行一段时间后平静关闭的系统是两码事”，后者要困难的多得多。&lt;/p&gt;

&lt;h2 id=&#34;吞吐量benchmark测试报告:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;吞吐量Benchmark测试报告&lt;/h2&gt;

&lt;p&gt;本文用 ping pong 测试来对比&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;与&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;、&lt;a href=&#34;http://www.boost.org/&#34;&gt;boost.asio&lt;/a&gt;、muduo] 等网络的吞吐量，测试结果表明&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;吞吐量与&lt;a href=&#34;http://www.boost.org/&#34;&gt;boost.asio&lt;/a&gt;、&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;等相当，比&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;高&lt;strong&gt;17%~130%&lt;/strong&gt;左右。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;本身是基于&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;实现的，不过&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;只是用了&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;的事件循环，并没有用&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;的&lt;code&gt;evbuffer&lt;/code&gt;，而是自己参考&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;和&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;实现了自己的网络IO读写类&lt;a href=&#34;https://github.com/Qihoo360/evpp/blob/master/evpp/buffer.h&#34;&gt;Buffer&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;性能测试相关的代码都在这里：&lt;a href=&#34;https://github.com/Qihoo360/evpp/tree/master/benchmark/&#34;&gt;https://github.com/Qihoo360/evpp/tree/master/benchmark/&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&#34;测试对象:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;测试对象&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp/archive/0.2.0.tar.gz&#34;&gt;evpp-0.2.0&lt;/a&gt; based on libevent-2.0.21&lt;/li&gt;
&lt;li&gt;boost.asio-1.53&lt;/li&gt;
&lt;li&gt;libevent-2.0.21&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;系统环境:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;系统环境&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;操作系统：Linux CentOS 6.2, 2.6.32-220.7.1.el6.x86_64&lt;/li&gt;
&lt;li&gt;硬件CPU：Intel&amp;reg; Xeon&amp;reg; CPU E5-2630 v2 @ 2.60GHz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-libevent-1thread-all.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/zieckey/resources/master/evpp/benchmark/throughput/evpp-vs-asio-1thread-all.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;几个简单的示例代码:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;几个简单的示例代码&lt;/h2&gt;

&lt;h2 id=&#34;tcp-echo服务器:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;TCP Echo服务器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;evpp/tcp_server.h&amp;gt;
#include &amp;lt;evpp/buffer.h&amp;gt;
#include &amp;lt;evpp/tcp_conn.h&amp;gt;

int main(int argc, char* argv[]) {
    std::string addr = &amp;quot;0.0.0.0:9099&amp;quot;;
    int thread_num = 4;
    evpp::EventLoop loop;
    evpp::TCPServer server(&amp;amp;loop, addr, &amp;quot;TCPEchoServer&amp;quot;, thread_num);
    server.SetMessageCallback([](const evpp::TCPConnPtr&amp;amp; conn,
                                 evpp::Buffer* msg,
                                 evpp::Timestamp ts) {
        conn-&amp;gt;Send(msg);
    });
    server.SetConnectionCallback([](const evpp::TCPConnPtr&amp;amp; conn) {
        if (conn-&amp;gt;IsConnected()) {
            LOG_INFO &amp;lt;&amp;lt; &amp;quot;A new connection from &amp;quot; &amp;lt;&amp;lt; conn-&amp;gt;remote_addr();
        } else {
            LOG_INFO &amp;lt;&amp;lt; &amp;quot;Lost the connection from &amp;quot; &amp;lt;&amp;lt; conn-&amp;gt;remote_addr();
        }
    });
    server.Init();
    server.Start();
    loop.Run();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;http-echo服务器:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;HTTP Echo服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;evpp/exp.h&amp;gt;
#include &amp;lt;evpp/http/http_server.h&amp;gt;

int main(int argc, char* argv[]) {
    std::vector&amp;lt;int&amp;gt; ports = { 9009, 23456, 23457 };
    int thread_num = 2;
    evpp::http::Server server(thread_num);
    server.RegisterHandler(&amp;quot;/echo&amp;quot;,
                           [](evpp::EventLoop* loop,
                              const evpp::http::ContextPtr&amp;amp; ctx,
                              const evpp::http::HTTPSendResponseCallback&amp;amp; cb) {
        cb(ctx-&amp;gt;body().ToString()); }
    );
    server.Init(ports);
    server.Start();
    while (!server.IsStopped()) {
        usleep(1);
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;udp-echo服务器:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;UDP Echo服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;evpp/exp.h&amp;gt;
#include &amp;lt;evpp/udp/udp_server.h&amp;gt;
#include &amp;lt;evpp/udp/udp_message.h&amp;gt;

int main(int argc, char* argv[]) {
    std::vector&amp;lt;int&amp;gt; ports = { 1053, 5353 };
    evpp::udp::Server server;
    server.SetMessageHandler([](evpp::EventLoop* loop, evpp::udp::MessagePtr&amp;amp; msg) {
        evpp::udp::SendMessage(msg);
    });
    server.Init(ports);
    server.Start();

    while (!server.IsStopped()) {
        usleep(1);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;致谢:936b642af201f8dee8eb70b9b4d592bb&#34;&gt;致谢&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;感谢&lt;a href=&#34;http://www.360.cn&#34; title=&#34;http://www.360.cn&#34;&gt;奇虎360公司&lt;/a&gt;对该项目的支持&lt;/li&gt;
&lt;li&gt;感谢&lt;a href=&#34;https://github.com/libevent/libevent&#34;&gt;libevent&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/glog&#34;&gt;glog&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/googletest&#34;&gt;gtest&lt;/a&gt;, &lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;等项目&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Qihoo360/evpp&#34;&gt;evpp&lt;/a&gt;深度参考了&lt;a href=&#34;https://github.com/chenshuo/muduo&#34;&gt;muduo&lt;/a&gt;项目的实现和设计，非常感谢&lt;a href=&#34;https://github.com/chenshuo&#34; title=&#34;https://github.com/chenshuo&#34;&gt;Chen Shuo&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>minio源码阅读</title>
      <link>http://blog.codeg.cn/post/blog/2016-09-06-minio-source-code-reading/</link>
      <pubDate>Tue, 06 Sep 2016 11:52:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-09-06-minio-source-code-reading/</guid>
      <description>

&lt;h2 id=&#34;简介:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;minio是Go实现的一个完全兼容S3的服务，和大多Go项目一样，干净小巧，没有依赖，编译运行一键搞定，便利之极。&lt;/p&gt;

&lt;h2 id=&#34;源码阅读:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;源码阅读&lt;/h2&gt;

&lt;h3 id=&#34;http事件注册:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;HTTP事件注册&lt;/h3&gt;

&lt;p&gt;启动阶段的初始化工作还是相当繁琐，没戏看。重点看一下运行期间的功能。&lt;/p&gt;

&lt;p&gt;minio进程起来了，对外提供HTTP服务，那么找到HTTP的事件注册的函数就是最好的入口点。事件处理函数的注册代码路径为：serverMain -&amp;gt; configureServerHandler -&amp;gt; api-router.go:registerAPIRouter&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;registerAPIRouter&lt;/code&gt;这个函数中，注册了所有HTTP相关的事件处理回调函数。事件分发使用了&lt;code&gt;github.com/gorilla/mux&lt;/code&gt;库。这个mux库，在Golang的项目中，使用率还是蛮多的，上次我在&lt;code&gt;Trafix&lt;/code&gt;项目中也看到是使用mux库来处理HTTP事件注册和分发处理。&lt;/p&gt;

&lt;h3 id=&#34;putobject-上传一个对象:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;PutObject：上传一个对象&lt;/h3&gt;

&lt;p&gt;注册回调函数为&lt;code&gt;bucket.Methods(&amp;quot;PUT&amp;quot;).Path(&amp;quot;/{object:.+}&amp;quot;).HandlerFunc(api.PutObjectHandler)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面我们来分析一下&lt;code&gt;func (api objectAPIHandlers) PutObjectHandler(w http.ResponseWriter, r *http.Request)&lt;/code&gt;函数的实现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先，检测HTTP HEADER中是否有设置 &lt;code&gt;X-Amz-Copy-Source&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检测HTTP HEADER中的&lt;code&gt;Content-Md5&lt;/code&gt;，并获取该MD5（注意：该MD5是16进制数Base64Encode之后的结果）&lt;/li&gt;
&lt;li&gt;检测是否有相应权限&lt;/li&gt;
&lt;li&gt;检测是否超过最大大小限制&lt;/li&gt;
&lt;li&gt;根据权限，调用相应的函数。这里我们重点介绍&lt;code&gt;api.ObjectAPI.PutObject(bucket, object, size, r.Body, metadata)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是单机版本，会进入&lt;code&gt;func (fs fsObjects) PutObject(bucket string, object string, size int64, data io.Reader, metadata map[string]string) (string, error)&lt;/code&gt;函数中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继续分析&lt;code&gt;func (fs fsObjects) PutObject(...)&lt;/code&gt;函数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先检测 BucketName、ObjectName 是否合法&lt;/li&gt;
&lt;li&gt;生成一个UUID，然后根据UUID生成一个唯一的临时的obj路径&lt;code&gt;tempObj&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;new一个MD5对象，用来计算上传的数据的MD5&lt;/li&gt;
&lt;li&gt;根据HTTP请求的Reader生成一个io.TeeReader对象，用来读取数据的同时，顺便计算一下MD5值&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;func fsCreateFile(...)&lt;/code&gt;来创建一个临时的对象文件&lt;/li&gt;
&lt;li&gt;再检查计算出来的MD5是否与HTTP HEADER中的MD5完全一致&lt;/li&gt;
&lt;li&gt;如果MD5不一致就删除临时文件，返回错误。如果MD5完全一致，就将临时文件Rename为目标文件&lt;/li&gt;
&lt;li&gt;最后，如果HTTP HEADER中有额外的meta数据需要写入，就调用&lt;code&gt;writeFSMetadata&lt;/code&gt;写入meta文件中&lt;/li&gt;
&lt;li&gt;最最后，返回数据的MD5值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面&lt;code&gt;func fsCreateFile(...)&lt;/code&gt;中，会调用&lt;code&gt;disk.AppendFile(...)&lt;/code&gt;来创建文件。如果是单机版，这个函数的具体实现为&lt;code&gt;func (s *posix) AppendFile(volume, path string, buf []byte) (err error)&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;getobject-查询一个对象:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;GetObject：查询一个对象&lt;/h3&gt;

&lt;p&gt;注册回调函数为&lt;code&gt;bucket.Methods(&amp;quot;GET&amp;quot;).Path(&amp;quot;/{object:.+}&amp;quot;).HandlerFunc(api.GetObjectHandler)&lt;/code&gt;，该函数分析如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从URL中获取 &lt;code&gt;bucket&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 的具体值&lt;/li&gt;
&lt;li&gt;检测是否有权限&lt;/li&gt;
&lt;li&gt;查询ObjectInfo数据&lt;/li&gt;
&lt;li&gt;检测HTTP HEADER看看，是否HTTP Range查询模式（也就是说minio支持断点续传）&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;api.ObjectAPI.GetObject&lt;/code&gt;来获取对象数据&lt;/li&gt;
&lt;li&gt;如果是单机版，会进入&lt;code&gt;func (fs fsObjects) GetObject(bucket, object string, offset int64, length int64, writer io.Writer) (err error)&lt;/code&gt;函数中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继续分析&lt;code&gt;func (fs fsObjects) GetObject(...)&lt;/code&gt;函数&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先检测 BucketName、ObjectName 是否合法&lt;/li&gt;
&lt;li&gt;继续检测其他参数是否合法，例如 offset、length 等&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;fs.storage.StatFile&lt;/code&gt;接口来获取对象文件的长度信息，并与请求参数做对比，核验是否合法&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;fs.storage.ReadFile&lt;/code&gt;来获取文件数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考:68197fcc8cceffccb0f0dc5b0599d2bc&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/minio/minio&#34;&gt;项目源码 https://github.com/minio/minio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;github.com/gorilla/mux&#34;&gt;mux项目官网 github.com/gorilla/mux&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>发布一个Golang版本的INI解析器</title>
      <link>http://blog.codeg.cn/post/blog/2016-05-29-a-new-ini-parser-for-golang/</link>
      <pubDate>Sun, 29 May 2016 13:14:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-05-29-a-new-ini-parser-for-golang/</guid>
      <description>

&lt;h2 id=&#34;goini:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;goini&lt;/h2&gt;

&lt;p&gt;这是一个为Golang开发的读取INI格式文件的库，它还能读取类似于INI格式的key/value对数据。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;goini&lt;/code&gt; 的设计目标是简单、灵活、高效，有如下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持标准INI格式&lt;/li&gt;
&lt;li&gt;支持节&lt;/li&gt;
&lt;li&gt;支持从本地磁盘中读取INI文件&lt;/li&gt;
&lt;li&gt;支持从内存数据中读取INI数据&lt;/li&gt;
&lt;li&gt;支持解析形如INI格式的key/value对数据，分隔符可以自定义&lt;/li&gt;
&lt;li&gt;支持UTF8编码&lt;/li&gt;
&lt;li&gt;支持注释符 &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持级联继承&lt;/li&gt;
&lt;li&gt;仅仅只依赖Golang标准库&lt;/li&gt;
&lt;li&gt;测试用户100%覆盖&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;使用时导入:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;使用时导入&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import github.com/zieckey/goini
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;用法示例:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;用法示例&lt;/h2&gt;

&lt;h3 id=&#34;示例1-解析ini文件:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;示例1 : 解析INI文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import github.com/zieckey/goini

ini := goini.New()
err := ini.ParseFile(filename)
if err != nil {
	fmt.Printf(&amp;quot;parse INI file %v failed : %v\n&amp;quot;, filename, err.Error())
	return
}

v, ok := ini.Get(&amp;quot;the-key&amp;quot;)
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例2-解析内存中形如ini格式的数据:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;示例2 ： 解析内存中形如INI格式的数据&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;raw := []byte(&amp;quot;a:av||b:bv||c:cv||||d:dv||||||&amp;quot;)
ini := goini.New()
err := ini.Parse(raw, &amp;quot;||&amp;quot;, &amp;quot;:&amp;quot;)
if err != nil {
    fmt.Printf(&amp;quot;parse INI memory data failed : %v\n&amp;quot;, err.Error())
    return
}

key := &amp;quot;a&amp;quot;
v, ok := ini.Get(key)
if ok {
    fmt.Printf(&amp;quot;The value of %v is [%v]\n&amp;quot;, key, v) // Output : The value of a is [av]
}

key = &amp;quot;c&amp;quot;
v, ok = ini.Get(key)
if ok {
    fmt.Printf(&amp;quot;The value of %v is [%v]\n&amp;quot;, key, v) // Output : The value of c is [cv]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例3-解析级联继承ini文件:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;示例3 : 解析级联继承INI文件&lt;/h3&gt;

&lt;p&gt;假设我们有一个项目，该项目会部署到多个不同的生产环境中，每一个生产环境的配置都不尽相同，一般情况下，就得为每一个环境分别管理其各自的配置。
为了简化配置，我们抽取各个生产环境中配置的公共部分形成一个 &lt;code&gt;common.ini&lt;/code&gt;, 然后让每个生产环境的配置从这个INI配置文件继承，
这样就可以大大简化配置文件的维护工作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;common.ini&lt;/code&gt; 举例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;product=common
combo=common
debug=0

version=0.0.0.0
encoding=0

[sss]
a = aval
b = bval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目 &lt;code&gt;project1.ini&lt;/code&gt; 从 &lt;code&gt;common.ini&lt;/code&gt; 继承而来，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;inherited_from=common.ini

;the following config will override the values inherited from common.ini
product=project1
combo=test
debug=1

local=0
mid=c4ca4238a0b923820dcc509a6f75849b

[sss]
a = project1-aval
c = project1-cval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个说话，我们使用 &lt;code&gt;goini.LoadInheritedINI(&amp;quot;project1.ini&amp;quot;)&lt;/code&gt; 来解析这个配置文件，其效果相当下面的INI配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;product=project1
combo=test
debug=1

local=0
mid=c4ca4238a0b923820dcc509a6f75849b

version=0.0.0.0
encoding=0

[sss]
a = project1-aval
c = project1-cval
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:8fa3c65ec3a305344ff164eb6635eadc&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zieckey/goini&#34;&gt;项目源码 https://github.com/zieckey/goini&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Trafik源代码阅读</title>
      <link>http://blog.codeg.cn/post/blog/2016-05-26-trafik-source-code-reading/</link>
      <pubDate>Thu, 26 May 2016 07:00:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-05-26-trafik-source-code-reading/</guid>
      <description>

&lt;h2 id=&#34;trafik介绍:34b0e58d062ee9acee54f0313b094782&#34;&gt;Trafik介绍&lt;/h2&gt;

&lt;p&gt;其&lt;a href=&#34;https://docs.traefik.io/&#34;&gt;官网&lt;/a&gt;是这么介绍的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Træfɪk is a modern HTTP reverse proxy and load balancer made to deploy microservices with ease. 
It supports several backends (Docker, Swarm, Mesos/Marathon, Consul, Etcd, Zookeeper, BoltDB, Rest API, file...) 
to manage its configuration automatically and dynamically.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;翻译过来就是：Træfɪk是一个现代的HTTP反向代理和易用的微服务负载平衡器，支持多种后端服务，
例如 Docker、 Swarm、 Mesos/Marathon、 Kubernetes、 Consul、 Etcd、 Zookeeper、 BoltDB、 Rest API、 文件 等等，
可以自动地动态管理和加载各种配置。&lt;/p&gt;

&lt;p&gt;特点如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;快速，benchmark显示，能够达到nginx的85%的性能&lt;/li&gt;
&lt;li&gt;没有依赖地狱，得益于Golang的特性，单个二进制文件就能运行&lt;/li&gt;
&lt;li&gt;Rest API&lt;/li&gt;
&lt;li&gt;监视后端，能够自动监听后端配置的变化。&lt;/li&gt;
&lt;li&gt;配置的热重加载，无需重新启动进程或服务器&lt;/li&gt;
&lt;li&gt;优雅地关闭Http连接&lt;/li&gt;
&lt;li&gt;后端的断路器Circuit breaker&lt;/li&gt;
&lt;li&gt;Round Robin rebalancer 负载平衡&lt;/li&gt;
&lt;li&gt;Rest测量&lt;/li&gt;
&lt;li&gt;包括小的官方docker&lt;/li&gt;
&lt;li&gt;SSL后端支持&lt;/li&gt;
&lt;li&gt;SSL前端支持&lt;/li&gt;
&lt;li&gt;干净的AngularJS Web UI&lt;/li&gt;
&lt;li&gt;支持Websocket&lt;/li&gt;
&lt;li&gt;支持Http/2&lt;/li&gt;
&lt;li&gt;如果网络错误重试请求&lt;/li&gt;
&lt;li&gt;自动Https支持(Let’s Encrypt)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;用法:34b0e58d062ee9acee54f0313b094782&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;最简单的用法当然是做一个HTTP反向代理用。&lt;/p&gt;

&lt;p&gt;假设我们有一个HTTP服务 &lt;code&gt;http://10.16.28.17:8091/echo&lt;/code&gt;, 我们用Trafik做为反向代理的配置 &lt;code&gt;trafik.toml&lt;/code&gt; 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;logLevel = &amp;quot;DEBUG&amp;quot;

defaultEntryPoints = [&amp;quot;http&amp;quot;]

[entryPoints]
  [entryPoints.http]
  address = &amp;quot;:8080&amp;quot;

[file]
  [backends]
    [backends.httpecho]
      [backends.httpecho.servers.server1]
        url = &amp;quot;http://10.16.28.17:8091&amp;quot;
        weight = 1
  [frontends]
    [frontends.fe1]
    backend = &amp;quot;httpecho&amp;quot;
      [frontends.fe1.routes.rule1]
      rule = &amp;quot;Path:/echo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考Trafik官方文档说明，我们这个配置解释如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将Trafik的日志级别 &lt;code&gt;logLevel&lt;/code&gt; 定义为 &lt;code&gt;DEBUG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认的接入点 &lt;code&gt;defaultEntryPoints&lt;/code&gt; 定义为 &lt;code&gt;http&lt;/code&gt;，并且其端口为 &lt;code&gt;8080&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后在 &lt;code&gt;[file]&lt;/code&gt; 段定义 &lt;code&gt;backends&lt;/code&gt; 和 &lt;code&gt;frontends&lt;/code&gt;， 也就是Trafik的路由转发规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backends&lt;/code&gt;段定义了一个后端服务，URL地址和权重都设置好了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontends&lt;/code&gt;段定义转发规则，即将URL路径为 /echo 的请求转发到合适的 &lt;code&gt;backend&lt;/code&gt; 上。&lt;/li&gt;
&lt;li&gt;然后我们可以用 curl 来测试转发是否正常： &lt;code&gt;curl http://localhost:8080/echo -d xxxxxx&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;源码阅读:34b0e58d062ee9acee54f0313b094782&#34;&gt;源码阅读&lt;/h2&gt;

&lt;h3 id=&#34;源码编译:34b0e58d062ee9acee54f0313b094782&#34;&gt;源码编译&lt;/h3&gt;

&lt;p&gt;按照官方文档的说明即可编译出来。其中几个需要的地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提前下载好 go-bindata 的源码并编译出二进制出来安装的 $PATH 路径下&lt;/li&gt;
&lt;li&gt;提前下载好 glide 的源码并编译出二进制出来安装的 $PATH 路径下&lt;/li&gt;
&lt;li&gt;如果在windows下编译的话，trafik依赖的一个 &lt;code&gt;github.com/mailgun/log&lt;/code&gt; 库支持unix系统，需要做一下修改。将&lt;code&gt;NewSysLogger&lt;/code&gt;函数修改如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewSysLogger(conf Config) (Logger, error) {
	debugW := os.Stdout
	infoW := os.Stdout
	warnW := os.Stdout
	errorW := os.Stdout

	sev, err := SeverityFromString(conf.Severity)
	if err != nil {
		return nil, err
	}

	return &amp;amp;sysLogger{sev, debugW, infoW, warnW, errorW}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;http多路分发器-mux:34b0e58d062ee9acee54f0313b094782&#34;&gt;HTTP多路分发器：mux&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;github.com/gorilla/mux&lt;/code&gt; 是一个HTTP多路分发器，其原理也比较简单，就是实现了Golang标准库中的 &lt;code&gt;net.http.Handler&lt;/code&gt; 接口，即如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当mux注册到HTTP服务之后，所有的HTTP请求就会由标准库 &lt;code&gt;net/http&lt;/code&gt; 转发到mux库中的 &lt;code&gt;func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/code&gt; 函数中，
mux.Router.ServeHTTP这个函数再进行自己的路由规则匹配和转发。&lt;/p&gt;

&lt;p&gt;Trafik使用 &lt;code&gt;github.com/gorilla/mux&lt;/code&gt; 库做路由转发。&lt;/p&gt;

&lt;h2 id=&#34;参考:34b0e58d062ee9acee54f0313b094782&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.traefik.io/&#34;&gt;官方网站 https://docs.traefik.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containous/traefik&#34;&gt;项目源码 https://github.com/containous/traefik&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>如何在win7 64位系统下安装gopcap包及使用</title>
      <link>http://blog.codeg.cn/post/blog/2016-05-26-howto-build-gopcap-on-windows-x64/</link>
      <pubDate>Wed, 25 May 2016 20:12:01 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-05-26-howto-build-gopcap-on-windows-x64/</guid>
      <description>

&lt;p&gt;&lt;code&gt;gopcap&lt;/code&gt;是libpcap库的Golang封装，其项目地址在这里 &lt;a href=&#34;https://github.com/akrennmair/gopcap&#34;&gt;https://github.com/akrennmair/gopcap&lt;/a&gt; 。
本文简要介绍一下如何在win7 64位系统平台上使用 &lt;code&gt;gopcap&lt;/code&gt; 库。&lt;/p&gt;

&lt;p&gt;安装步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装Golang 64位版本&lt;/li&gt;
&lt;li&gt;安装mingw 64位版本，注意导入到windows环境变量中。让命令行能自动找到 gcc 命令&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;http://www.tcpdump.org/&#34;&gt;http://www.tcpdump.org/&lt;/a&gt; 下载 libpcap-1.7.4.tar.gz，从这个包中得到libpcap的C语言头文件&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;https://www.winpcap.org/install/&#34;&gt;https://www.winpcap.org/install/&lt;/a&gt; 下载winpcap并安装，从这里可以得到libpcap的windows DLL文件 wpcap.dll，用于运行&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;http://www.winpcap.org/archive/&#34;&gt;http://www.winpcap.org/archive/&lt;/a&gt; 下载 4.1.1-WpdPack.zip，从其中的x64目录下找到 wpcap.lib 库，用于编译&lt;/li&gt;
&lt;li&gt;执行下列命令：
&lt;pre&gt;
mkdir -p /c/wpdpcak/include
mkdir -p /c/wpdpcak/lib/x64
cp /c/Windows/System32/wpcap.dll /c/wpdpack/lib/x64/
cp -rf libpcap-1.7.4/Win32/Include/* /c/wpdpack/include/
cp -rf libpcap-1.7.4/pcap.h libpcap-1.7.4/pcap /c/wpdpack/include/
cp -rf 4.1.1-WpdPack/WpdPack/Lib/x64/wpcap.lib /c/wpdpcak/lib/x64
&lt;/pre&gt;
这里，将相关头文库、库文件都放在 &lt;code&gt;C:\wpdpcak&lt;/code&gt; 目录下，是因为 gopcap 库的cgo编译选择是这么设置，当然你也可以修改源码的方式来重新设置目录。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译过程中如果出现下列错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go build
# github.com/akrennmair/gopcap
In file included from C:/WpdPack/Include/pcap.h:43:0,
          from ..\..\..\akrennmair\gopcap\pcap.go:12:
C:/WpdPack/Include/pcap/pcap.h:450:1: error: unknown type name &#39;Adapter&#39;
Adapter *pcap_get_adapter(pcap_t *p);
^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就将 pcap/pcap.h 中这一行注释掉。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至此，应该再不会有问题了，编译成功。 gopcap 库的toots目录有很多使用用例，可以看看以了解如何使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考:74f61569ed0f5a8ab78927a7660545ad&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/c-go-cgo&#34;&gt;http://blog.golang.org/c-go-cgo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/akrennmair/gopcap&#34;&gt;https://github.com/akrennmair/gopcap&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Golang CGO编程之调用返回char*指针及长度的C函数库</title>
      <link>http://blog.codeg.cn/post/blog/2016-04-20-golang-cgo/</link>
      <pubDate>Wed, 20 Apr 2016 21:43:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-04-20-golang-cgo/</guid>
      <description>

&lt;p&gt;现代所有主流操作系统几乎都是用C语音实现的，几乎所有高级语言都能调用C语言，例如PHP可以调用C语言写的PHP扩展，Python也可以调用C语言实现的Python扩展。
Golang语言也不例外。&lt;/p&gt;

&lt;p&gt;Golang通过CGO机制能很方便的调用C语言。本文介绍一下如何在Go中调用稍稍复杂一点C函数，例如： &lt;code&gt;char* f(int, int*)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先看一个最简单的例子，将Golang中的一个字符串传入C函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void print(char *str) {
    printf(&amp;quot;%s\n&amp;quot;, str);
}
*/
import &amp;quot;C&amp;quot;

import &amp;quot;unsafe&amp;quot;

func main() {
    s := &amp;quot;Hello Cgo&amp;quot;
    cs := C.CString(s)
    C.print(cs)
    C.free(unsafe.Pointer(cs))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上述程序中的关键语句&lt;code&gt;cs := C.CString(s)&lt;/code&gt;是将一个Golang的字符串转换为C语言字符串，该C语言字符串是由C函数malloc从堆中分配的，因此后续需要调用 &lt;code&gt;C.free&lt;/code&gt; 释放内存。&lt;/p&gt;

&lt;p&gt;然后，我们看看如何调用一个复杂一点的C函数？例如： &lt;code&gt;char* f(int, int*)&lt;/code&gt; ，返回一个&lt;code&gt;char*&lt;/code&gt;指针，并且有一个参数也是返回值&lt;code&gt;int*&lt;/code&gt;。请直接看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
char* xmalloc(int len, int *rlen)
{
    static const char* s = &amp;quot;0123456789&amp;quot;;
    char* p = malloc(len);
    if (len &amp;lt;= strlen(s)) {
        memcpy(p, s, len);
    } else {
        memset(p, &#39;a&#39;, len);
    }
    *rlen = len;
    return p;
}
*/
import &amp;quot;C&amp;quot;
import &amp;quot;unsafe&amp;quot;
import &amp;quot;fmt&amp;quot;

func main() {
	rlen := C.int(0)
	len := 10
	cstr := C.xmalloc(C.int(len), &amp;amp;rlen)
	defer C.free(unsafe.Pointer(cstr))
	gostr := C.GoStringN(cstr, rlen)
	fmt.Printf(&amp;quot;retlen=%v\n&amp;quot;, rlen)
	println(gostr)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xmalloc&lt;/code&gt;函数的第二个参数是&lt;code&gt;int*&lt;/code&gt;，这里设计为一个输入、输出参数。我们在Golang中使用C.int类型的指针就可以；
其返回值是一个&lt;code&gt;char*&lt;/code&gt;，在Golang中就是 &lt;code&gt;*C.char&lt;/code&gt;，由于返回值是指针，其内存由malloc分配，因此需要在Golang中对其内存进行释放。&lt;/p&gt;

&lt;p&gt;再然后，我们看看如何调用一个返回结构体的C函数？例如：&lt;code&gt;struct MyString xmalloc(int len)&lt;/code&gt;。请看示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

struct MyString
{
    char* s;
    int len;
};

struct MyString xmalloc(int len)
{
    static const char* s = &amp;quot;0123456789&amp;quot;;
    char* p = malloc(len);
    if (len &amp;lt;= strlen(s)) {
        memcpy(p, s, len);
    } else {
        memset(p, &#39;a&#39;, len);
    }
    struct MyString str;
    str.s = p;
    str.len = len;
    return str;
}
*/
import &amp;quot;C&amp;quot;
import &amp;quot;unsafe&amp;quot;
import &amp;quot;fmt&amp;quot;

func main() {
	len := 10
	str := C.xmalloc(C.int(len))
	defer C.free(unsafe.Pointer(str.s))
	gostr := C.GoStringN(str.s, str.len)
	fmt.Printf(&amp;quot;retlen=%v\n&amp;quot;, str.len)
	println(gostr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:1d9c7bc1f63996ea5a05ef9bf93a075a&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/c-go-cgo&#34;&gt;http://blog.golang.org/c-go-cgo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/cmd/cgo/&#34;&gt;https://golang.org/cmd/cgo/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>使用Golang利用ectd实现一个分布式锁</title>
      <link>http://blog.codeg.cn/post/blog/2016-02-24-distrubute-lock-over-etcd/</link>
      <pubDate>Wed, 24 Feb 2016 20:43:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/blog/2016-02-24-distrubute-lock-over-etcd/</guid>
      <description>

&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;是随着&lt;code&gt;CoreOS&lt;/code&gt;项目一起成长起来的，随着Golang和CoreOS等项目在开源社区日益火热，
&lt;code&gt;etcd&lt;/code&gt;作为一个高可用、强一致性的分布式Key-Value存储系统被越来越多的开发人员关注和使用。&lt;/p&gt;

&lt;p&gt;这篇&lt;a href=&#34;http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle&#34;&gt;文章&lt;/a&gt;全方位介绍了etcd的应用场景，这里简单摘要如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务发现（Service Discovery）&lt;/li&gt;
&lt;li&gt;消息发布与订阅&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;分布式通知与协调&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;分布式队列&lt;/li&gt;
&lt;li&gt;集群监控与Leader竞选&lt;/li&gt;
&lt;li&gt;为什么用etcd而不用ZooKeeper&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文重点介绍如何利用&lt;code&gt;ectd&lt;/code&gt;实现一个分布式锁。
锁的概念大家都熟悉，当我们希望某一事件在同一时间点只有一个线程(goroutine)在做，或者某一个资源在同一时间点只有一个服务能访问，这个时候我们就需要用到锁。
例如我们要实现一个分布式的id生成器，多台服务器之间的协调就非常麻烦。分布式锁就正好派上用场。&lt;/p&gt;

&lt;p&gt;其基本实现原理为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在ectd系统里创建一个key&lt;/li&gt;
&lt;li&gt;如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1&lt;/li&gt;
&lt;li&gt;如果创建成功，则认为我获得了锁&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package etcdsync

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/coreos/etcd/client&amp;quot;
	&amp;quot;github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context&amp;quot;
)

const (
	defaultTTL = 60
	defaultTry = 3
	deleteAction = &amp;quot;delete&amp;quot;
	expireAction = &amp;quot;expire&amp;quot;
)

// A Mutex is a mutual exclusion lock which is distributed across a cluster.
type Mutex struct {
	key    string
	id     string // The identity of the caller
	client client.Client
	kapi   client.KeysAPI
	ctx    context.Context
	ttl    time.Duration
	mutex  *sync.Mutex
	logger io.Writer
}

// New creates a Mutex with the given key which must be the same
// across the cluster nodes.
// machines are the ectd cluster addresses
func New(key string, ttl int, machines []string) *Mutex {
	cfg := client.Config{
		Endpoints:               machines,
		Transport:               client.DefaultTransport,
		HeaderTimeoutPerRequest: time.Second,
	}

	c, err := client.New(cfg)
	if err != nil {
		return nil
	}

	hostname, err := os.Hostname()
	if err != nil {
		return nil
	}

	if len(key) == 0 || len(machines) == 0 {
		return nil
	}

	if key[0] != &#39;/&#39; {
		key = &amp;quot;/&amp;quot; + key
	}

	if ttl &amp;lt; 1 {
		ttl = defaultTTL
	}

	return &amp;amp;Mutex{
		key:    key,
		id:     fmt.Sprintf(&amp;quot;%v-%v-%v&amp;quot;, hostname, os.Getpid(), time.Now().Format(&amp;quot;20060102-15:04:05.999999999&amp;quot;)),
		client: c,
		kapi:   client.NewKeysAPI(c),
		ctx: context.TODO(),
		ttl: time.Second * time.Duration(ttl),
		mutex:  new(sync.Mutex),
	}
}

// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() (err error) {
	m.mutex.Lock()
	for try := 1; try &amp;lt;= defaultTry; try++ {
		if m.lock() == nil {
			return nil
		}
		
		m.debug(&amp;quot;Lock node %v ERROR %v&amp;quot;, m.key, err)
		if try &amp;lt; defaultTry {
			m.debug(&amp;quot;Try to lock node %v again&amp;quot;, m.key, err)
		}
	}
	return err
}

func (m *Mutex) lock() (err error) {
	m.debug(&amp;quot;Trying to create a node : key=%v&amp;quot;, m.key)
	setOptions := &amp;amp;client.SetOptions{
		PrevExist:client.PrevNoExist,
		TTL:      m.ttl,
	}
	resp, err := m.kapi.Set(m.ctx, m.key, m.id, setOptions)
	if err == nil {
		m.debug(&amp;quot;Create node %v OK [%q]&amp;quot;, m.key, resp)
		return nil
	}
	m.debug(&amp;quot;Create node %v failed [%v]&amp;quot;, m.key, err)
	e, ok := err.(client.Error)
	if !ok {
		return err
	}

	if e.Code != client.ErrorCodeNodeExist {
		return err
	}

	// Get the already node&#39;s value.
	resp, err = m.kapi.Get(m.ctx, m.key, nil)
	if err != nil {
		return err
	}
	m.debug(&amp;quot;Get node %v OK&amp;quot;, m.key)
	watcherOptions := &amp;amp;client.WatcherOptions{
		AfterIndex : resp.Index,
		Recursive:false,
	}
	watcher := m.kapi.Watcher(m.key, watcherOptions)
	for {
		m.debug(&amp;quot;Watching %v ...&amp;quot;, m.key)
		resp, err = watcher.Next(m.ctx)
		if err != nil {
			return err
		}

		m.debug(&amp;quot;Received an event : %q&amp;quot;, resp)
		if resp.Action == deleteAction || resp.Action == expireAction {
			return nil
		}
	}

}

// Unlock unlocks m.
// It is a run-time error if m is not locked on entry to Unlock.
//
// A locked Mutex is not associated with a particular goroutine.
// It is allowed for one goroutine to lock a Mutex and then
// arrange for another goroutine to unlock it.
func (m *Mutex) Unlock() (err error) {
	defer m.mutex.Unlock()
	for i := 1; i &amp;lt;= defaultTry; i++ {
		var resp *client.Response
		resp, err = m.kapi.Delete(m.ctx, m.key, nil)
		if err == nil {
			m.debug(&amp;quot;Delete %v OK&amp;quot;, m.key)
			return nil
		}
		m.debug(&amp;quot;Delete %v falied: %q&amp;quot;, m.key, resp)
		e, ok := err.(client.Error)
		if ok &amp;amp;&amp;amp; e.Code == client.ErrorCodeKeyNotFound {
			return nil
		}
	}
	return err
}

func (m *Mutex) debug(format string, v ...interface{}) {
	if m.logger != nil {
		m.logger.Write([]byte(m.id))
		m.logger.Write([]byte(&amp;quot; &amp;quot;))
		m.logger.Write([]byte(fmt.Sprintf(format, v...)))
		m.logger.Write([]byte(&amp;quot;\n&amp;quot;))
	}
}

func (m *Mutex) SetDebugLogger(w io.Writer) {
	m.logger = w
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实类似的实现有很多，但目前都已经过时，使用的都是被官方标记为&lt;code&gt;deprecated&lt;/code&gt;的项目。且大部分接口都不如上述代码简单。
使用上，跟Golang官方sync包的Mutex接口非常类似，先&lt;code&gt;New()&lt;/code&gt;，然后调用&lt;code&gt;Lock()&lt;/code&gt;，使用完后调用&lt;code&gt;Unlock()&lt;/code&gt;，就三个接口，就是这么简单。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/zieckey/etcdsync&amp;quot;
	&amp;quot;log&amp;quot;
)

func main() {
	//etcdsync.SetDebug(true)
	log.SetFlags(log.Ldate|log.Ltime|log.Lshortfile)
	m := etcdsync.New(&amp;quot;/etcdsync&amp;quot;, &amp;quot;123&amp;quot;, []string{&amp;quot;http://127.0.0.1:2379&amp;quot;})
	if m == nil {
		log.Printf(&amp;quot;etcdsync.NewMutex failed&amp;quot;)
	}
	err := m.Lock()
	if err != nil {
		log.Printf(&amp;quot;etcdsync.Lock failed&amp;quot;)
	} else {
		log.Printf(&amp;quot;etcdsync.Lock OK&amp;quot;)
	}

	log.Printf(&amp;quot;Get the lock. Do something here.&amp;quot;)

	err = m.Unlock()
	if err != nil {
		log.Printf(&amp;quot;etcdsync.Unlock failed&amp;quot;)
	} else {
		log.Printf(&amp;quot;etcdsync.Unlock OK&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:cc4776a5974d000eb2d6ff22e22b2c04&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zieckey/etcdsync&#34;&gt;etcdsync项目地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;ectd项目官方地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>将博客从jekyll迁移到hugo</title>
      <link>http://blog.codeg.cn/post/opinion/2016-02-20-migrate-to-hugo-from-jekyll/</link>
      <pubDate>Sat, 20 Feb 2016 22:43:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/post/opinion/2016-02-20-migrate-to-hugo-from-jekyll/</guid>
      <description>

&lt;p&gt;之前的博客内容都是用&lt;code&gt;jekyll&lt;/code&gt;来渲染的，这是用ruby写，部署起来比较麻烦。最近看到Golang开发的 &lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt; 工具，真是眼前一亮啊。&lt;/p&gt;

&lt;p&gt;促使我做这种迁移的动机有一下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我不会ruby，&amp;rsquo;臣妾&amp;rsquo;真的做不到&lt;/li&gt;
&lt;li&gt;我会Golang，用Golang写过一些小程序&lt;/li&gt;
&lt;li&gt;CoderZh提供的模板比较对我的眼缘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从昨晚到今天折腾了一天，终于迁移成功。谢谢&lt;a href=&#34;http://blog.coderzh.com&#34;&gt;CoderZh&lt;/a&gt;的奉献。&lt;/p&gt;

&lt;h2 id=&#34;参考:5c4da8f98a58690dc13b3af20af3f523&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gohugo.org/post/coderzh-hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>编译Golang包为C语言库文件</title>
      <link>http://blog.codeg.cn/2016/02/19/sharing-golang-package-to-C/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/2016/02/19/sharing-golang-package-to-C/</guid>
      <description>

&lt;p&gt;Go 1.5发布后，其包含一个特性：可以编译生成C语言动态链接库或静态库。本文给出了示例代码和用法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go build&lt;/code&gt;和&lt;code&gt;go install&lt;/code&gt;命令，可以使用参数 &lt;code&gt;-buildmode&lt;/code&gt; 来指定生成哪种类型的二进制目标文件。请见&lt;a href=&#34;https://golang.org/cmd/go/&#34;&gt;https://golang.org/cmd/go/#Description of build modes&lt;/a&gt; 详细说明。&lt;/p&gt;

&lt;p&gt;当前我们使用 &lt;code&gt;-buildmode=c-archive&lt;/code&gt; 来示例和测试。&lt;/p&gt;

&lt;p&gt;Golang源文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// file hello.go
package main

  port &amp;quot;C&amp;quot;
import &amp;quot;fmt&amp;quot;

//export SayHello
func SayHello(name string) {
    fmt.Printf(&amp;quot;func in Golang SayHello says: Hello, %s!\n&amp;quot;, name)
}

//export SayHelloByte
func SayHelloByte(name []byte) {
    fmt.Printf(&amp;quot;func in Golang SayHelloByte says: Hello, %s!\n&amp;quot;, string(name))
}

//export SayBye
func SayBye() {
    fmt.Println(&amp;quot;func in Golang SayBye says: Bye!&amp;quot;)
}

func main() {
    // We need the main function to make possible
    // CGO compiler to compile the package as C shared library
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令&lt;code&gt;go build -buildmode=c-archive -o libhello.a hello.go&lt;/code&gt;可以生成一个C语言静态库&lt;code&gt;libhello.a&lt;/code&gt;和头文件&lt;code&gt;libhello.h&lt;/code&gt;。
然后我们再写个C语言程序来调用这个库，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// file hello.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;libhello.h&amp;quot;

int main() {
  printf(&amp;quot;This is a C Application.\n&amp;quot;);
  GoString name = {(char*)&amp;quot;Jane&amp;quot;, 4};
  SayHello(name);
  GoSlice buf = {(void*)&amp;quot;Jane&amp;quot;, 4, 4};
  SayHelloByte(buf);
  SayBye();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命令&lt;code&gt;gcc -o hello hello.c libhello.a -pthread&lt;/code&gt;来编译生成一个可执行文件&lt;code&gt;hello&lt;/code&gt;。执行命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go build -buildmode=c-archive -o libhello.a hello.go
$ gcc -o hello hello.c libhello.a -pthread
$ ./hello 
This is a C Application.
func in Golang SayHello says: Hello, Jane!
func in Golang SayHelloByte says: Hello, Jane!
func in Golang SayBye says: Bye!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注：目前Golang还不支持将一个struct结构导出到C库中。&lt;/p&gt;

&lt;h2 id=&#34;参考:d07f2a12ab89ca994adea10c36662f05&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ralch.com/tutorial/golang-sharing-libraries/&#34;&gt;Sharing Golang packages to C and Go&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Golang发送邮件</title>
      <link>http://blog.codeg.cn/2016/02/14/send-email-for-golang/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/2016/02/14/send-email-for-golang/</guid>
      <description>

&lt;p&gt;本文介绍一个简单的方法使用Go语言发送邮件。直接调用系统自带的&lt;code&gt;mail&lt;/code&gt;命令发送邮件。&lt;/p&gt;

&lt;p&gt;在网上找了很多例子，基本上都是基于Golang本身自带的&lt;code&gt;smtp&lt;/code&gt;包来实现的，参考 &lt;a href=&#34;http://www.tuicool.com/articles/e2qUv2&#34;&gt;http://www.tuicool.com/articles/e2qUv2&lt;/a&gt;，这里需要以下几个关键信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;邮箱地址(邮箱用户名)&lt;/li&gt;
&lt;li&gt;邮箱密码&lt;/li&gt;
&lt;li&gt;邮件提供商hostname&lt;/li&gt;
&lt;li&gt;smtp服务器地址和端口&lt;/li&gt;
&lt;li&gt;邮件主题、正文、接收人列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述5个信息中，实际上我们关心的其实只有第5个，其他4个都不是太关心。而且，如果我们想写一段开源代码，这里就把邮箱用户名和密码给暴露了，不太合适。我于是想到了PHP中的&lt;code&gt;mail&lt;/code&gt;这个发送邮件的函数来，PHP是如何实现邮件发送的功能呢？我搜素PHP的源码发现在非Windows平台使用的系统自带的&lt;code&gt;sendmail&lt;/code&gt;命令来发送的，具体代码请参考: php-5.3.3/ext/standard/mail.c:php_mail&lt;/p&gt;

&lt;p&gt;受此启发，我在golang中也这么实现不就简单了么？下面是源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;os/exec&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;runtime&amp;quot;
)

// SendMail sends an email to the addresses using &#39;mail&#39; command on *nux platform.
func SendMail(title, message string, email ...string) error {
	if runtime.GOOS == &amp;quot;windows&amp;quot; {
		log.Printf(&amp;quot;TODO: cannot send email on windows title=[%v] messagebody=[%v]&amp;quot;, title, message)
		return nil
	}
	mailCommand := exec.Command(&amp;quot;mail&amp;quot;, &amp;quot;-s&amp;quot;, title)
	mailCommand.Args = append(mailCommand.Args, email...)
	stdin, err := mailCommand.StdinPipe()
	if err != nil {
		log.Printf(&amp;quot;StdinPipe failed to perform: %s (Command: %s, Arguments: %s)&amp;quot;, err, mailCommand.Path, mailCommand.Args)
		return err
	}
	stdin.Write([]byte(message))
	stdin.Close()
	_, err = mailCommand.Output()
	if err != nil || !mailCommand.ProcessState.Success() {
		log.Printf(&amp;quot;send email ERROR : &amp;lt;%v&amp;gt; title=[%v] messagebody=[%v]&amp;quot;, err.Error(), title, message)
		return err
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述源码放到这里了： &lt;a href=&#34;https://github.com/zieckey/gocom/tree/master/tmail&#34;&gt;https://github.com/zieckey/gocom/tree/master/tmail&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考:6819fbcd570de1ca567e85fb36deeb5f&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/articles/e2qUv2&#34;&gt;Golang Go语言发送邮件的方法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>