<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="CodeG Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="http://blog.codeg.cn//">
    <meta property="twitter:image" content="http://blog.codeg.cn//" />
    

    
    <meta name="title" content="源码阅读-悟空搜索引擎" />
    <meta property="og:title" content="源码阅读-悟空搜索引擎" />
    <meta property="twitter:title" content="源码阅读-悟空搜索引擎" />
    

    
    <meta name="description" content="悟空开源项目是用Go语言编写的全文搜索引擎。它不是一个完整的搜索引擎，是一个容易被修改的、能融入你的业务需求的基础代码，这些代码只实现基本功能，同时也足够精简，让你能了然于心，可以快速修改实现你想要的功能。">
    <meta property="og:description" content="悟空开源项目是用Go语言编写的全文搜索引擎。它不是一个完整的搜索引擎，是一个容易被修改的、能融入你的业务需求的基础代码，这些代码只实现基本功能，同时也足够精简，让你能了然于心，可以快速修改实现你想要的功能。" />
    <meta property="twitter:description" content="悟空开源项目是用Go语言编写的全文搜索引擎。它不是一个完整的搜索引擎，是一个容易被修改的、能融入你的业务需求的基础代码，这些代码只实现基本功能，同时也足够精简，让你能了然于心，可以快速修改实现你想要的功能。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="http://blog.codeg.cn/img/favicon.ico">

    <title>源码阅读-悟空搜索引擎 | </title>

    <link rel="canonical" href="http://blog.codeg.cn/2016/02/02/wukong-source-code-reading/">

    
    
    
    <link rel="stylesheet" href="http://blog.codeg.cn/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="http://blog.codeg.cn/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="http://blog.codeg.cn/css/zanshang.css">

    
    <link rel="stylesheet" href="http://blog.codeg.cn/css/font-awesome.all.min.css">

    
    

    
    <script src="http://blog.codeg.cn/js/jquery.min.js"></script>

    
    <script src="http://blog.codeg.cn/js/bootstrap.min.js"></script>

    
    <script src="http://blog.codeg.cn/js/hux-blog.min.js"></script>

    
    <script src="http://blog.codeg.cn/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://blog.codeg.cn/">CodeG Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="http://blog.codeg.cn/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="http://blog.codeg.cn/categories/blog/">blog</a>
                        </li>
                        
                        <li>
                            <a href="http://blog.codeg.cn/categories/finance/">finance</a>
                        </li>
                        
                        <li>
                            <a href="http://blog.codeg.cn/categories/opinion/">opinion</a>
                        </li>
                        
                        <li>
                            <a href="http://blog.codeg.cn/categories/project/">project</a>
                        </li>
                        
                        <li>
                            <a href="http://blog.codeg.cn/categories/study/">study</a>
                        </li>
                        
                    
                    
		    
		            <li>
                        <a href="http://blog.codeg.cn/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="http://blog.codeg.cn/tags/Golang" title="Golang">
                            Golang
                        </a>
                        
                    </div>
                    <h1>源码阅读-悟空搜索引擎</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    CodeG Blog
                             
                            on 
                            Tuesday, February 2, 2016
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h2 id="一个最简单的例子">一个最简单的例子</h2>
<p>我们还是从一个最简单的示例代码开始：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/huichen/wukong/engine&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/huichen/wukong/types&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="c1">// searcher是协程安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">searcher</span> <span class="p">=</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">Engine</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">searcher</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">EngineInitOptions</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">SegmenterDictionaries</span><span class="p">:</span> <span class="s">&#34;./data/dictionary.txt&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">searcher</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将文档加入索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">searcher</span><span class="p">.</span><span class="nf">IndexDocument</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">DocumentIndexData</span><span class="p">{</span><span class="nx">Content</span><span class="p">:</span> <span class="s">&#34;此次百度收购将成中国互联网最大并购&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">searcher</span><span class="p">.</span><span class="nf">IndexDocument</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">DocumentIndexData</span><span class="p">{</span><span class="nx">Content</span><span class="p">:</span> <span class="s">&#34;百度宣布拟全资收购91无线业务&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">searcher</span><span class="p">.</span><span class="nf">IndexDocument</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">DocumentIndexData</span><span class="p">{</span><span class="nx">Content</span><span class="p">:</span> <span class="s">&#34;百度是中国最大的搜索引擎&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 等待索引刷新完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">searcher</span><span class="p">.</span><span class="nf">FlushIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 搜索输出格式见types.SearchResponse结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">searcher</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">{</span><span class="nx">Text</span><span class="p">:</span><span class="s">&#34;百度中国&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;num=%d &#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">NumDocs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Docs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;docId=%d&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">DocId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;\tscore:&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;\tTokenLocations:&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">TokenLocations</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;\tTokenSnippetLocations:&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">TokenSnippetLocations</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>悟空搜索引擎不是一个完整的搜索引擎，我们可以把它当做一个搜索引擎基础库来使用。上面的示例代码是一个最简单的例子，展示了如何使用这个库，非常简单，三步即可完成：</p>
<ol>
<li>初始化引擎： <code>searcher.Init</code></li>
<li>将文档加入索引列表中： <code>searcher.IndexDocument</code></li>
<li>执行搜索任务：<code>searcher.Search</code></li>
</ol>
<h2 id="悟空搜索引擎内部整体框架图">悟空搜索引擎内部整体框架图</h2>
<p>引擎中处理用户请求、分词、索引和排序分别由不同的协程（goroutines）完成。</p>
<ol>
<li>主协程，用于收发用户请求</li>
<li>分词器（segmenter）协程，负责分词</li>
<li>索引器（indexer）协程，负责建立和查找索引表</li>
<li>排序器（ranker）协程，负责对文档评分排序</li>
</ol>
<p>
  <img src="http://blog.codeg.cn/images/githubpages/wukong-framework.png" alt="">

</p>
<h2 id="引擎初始化过程">引擎初始化过程</h2>
<p>从上面最简单的那个例子可以看出，我们所有的操作都是基于<code>searcher</code>对象（engine.Engine类型），初始化引擎、将文档加入索引列表中、Flush索引列表、执行搜索任务。下面我们详细分析一下初始化过程：</p>
<h4 id="加载分词词典">加载分词词典</h4>
<p>有一个参数<code>NotUsingSegmenter</code>可以控制是否加载分词词典。小小吐槽一下：这里没有使用正语义，导致我脑袋需要非非转换，(⊙o⊙)… ，我相信如果使用<code>UsingSegmenter</code>参数的话，应该更好理解一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">options</span><span class="p">.</span><span class="nx">NotUsingSegmenter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 载入分词器词典
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">engine</span><span class="p">.</span><span class="nx">segmenter</span><span class="p">.</span><span class="nf">LoadDictionary</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">SegmenterDictionaries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化停用词
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">engine</span><span class="p">.</span><span class="nx">stopTokens</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">StopTokenFile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>分词词典的内部加载过程，可以详细参考 <code>https://github.com/huichen/sego</code> 这个项目，这个可以单独来分析，在这里就不在展开说了。</p>
<h4 id="初始化索引器和排序器">初始化索引器和排序器</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">shard</span> <span class="p">&lt;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">;</span> <span class="nx">shard</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">indexers</span><span class="p">,</span> <span class="nx">core</span><span class="p">.</span><span class="nx">Indexer</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexers</span><span class="p">[</span><span class="nx">shard</span><span class="p">].</span><span class="nf">Init</span><span class="p">(</span><span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">IndexerInitOptions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">rankers</span><span class="p">,</span> <span class="nx">core</span><span class="p">.</span><span class="nx">Ranker</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankers</span><span class="p">[</span><span class="nx">shard</span><span class="p">].</span><span class="nf">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p><code>options.NumShards</code> 参数可以设置<code>shard</code>(分片，项目作者称之为裂分)个数，根据<code>shard</code>个数来初始化索引器(Indexer)、排序器(Rander)的个数。这里是为了方便并行处理，每一个<code>shard</code>都有一个索引器(Indexer)和排序器(Rander)，并提前初始化好。</p>
<h4 id="初始化分词器通道">初始化分词器通道</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">segmenterChannel</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="kd">chan</span> <span class="nx">segmenterRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumSegmenterThreads</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="初始化索引器通道">初始化索引器通道</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerAddDocumentChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">indexerAddDocumentRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerRemoveDocChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">indexerRemoveDocRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerLookupChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">indexerLookupRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">shard</span> <span class="p">&lt;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">;</span> <span class="nx">shard</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerAddDocumentChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">indexerAddDocumentRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">IndexerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerRemoveDocChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">indexerRemoveDocRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">IndexerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerLookupChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">indexerLookupRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">IndexerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>从这里可以看出索引器(Indexer)有三个功能：将一个文档添加到索引中、将一个文档从索引中移除、从索引中查找一个文档。每一个<code>shard</code>都有独立的<code>channel</code>，互不冲突。</p>
<h4 id="初始化排序器通道">初始化排序器通道</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerAddDocChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">rankerAddDocRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerRankChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">rankerRankRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerRemoveDocChannels</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="p">[]</span><span class="kd">chan</span> <span class="nx">rankerRemoveDocRequest</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">shard</span> <span class="p">&lt;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">;</span> <span class="nx">shard</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerAddDocChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">rankerAddDocRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">RankerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerRankChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">rankerRankRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">RankerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankerRemoveDocChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="nx">rankerRemoveDocRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">options</span><span class="p">.</span><span class="nx">RankerBufferLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>与上面类似，从这里可以看出排序器(Rander)有三个功能：将一个文档添加到排序器中、在排序器中进行排序、将一个文档从排序器中移除。每一个<code>shard</code>都有独立的<code>channel</code>，互不冲突。</p>
<h4 id="初始化持久化存储通道">初始化持久化存储通道</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">UsePersistentStorage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">persistentStorageIndexDocumentChannels</span> <span class="p">=</span>
</span></span><span class="line"><span class="cl">			<span class="nb">make</span><span class="p">([]</span><span class="kd">chan</span> <span class="nx">persistentStorageIndexDocumentRequest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">PersistentStorageShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">shard</span> <span class="p">&lt;</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">PersistentStorageShards</span><span class="p">;</span> <span class="nx">shard</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">engine</span><span class="p">.</span><span class="nx">persistentStorageIndexDocumentChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">				<span class="kd">chan</span> <span class="nx">persistentStorageIndexDocumentRequest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">persistentStorageInitChannel</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">PersistentStorageShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>注意：<code>PersistentStorageShards</code>持久化存储的分片数目是独立参数控制的。</p>
<h4 id="启动各个功能协程goroutine">启动各个功能协程goroutine</h4>
<ol>
<li>启动分词器协程</li>
<li>启动索引器和排序器协程</li>
<li>启动持久化存储工作协程</li>
</ol>
<p>至此，所有初始化工作完毕。</p>
<h2 id="索引过程分析">索引过程分析</h2>
<p>下面我们来分析索引过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 将文档加入索引
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 输入参数：
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	docId	标识文档编号，必须唯一
</span></span></span><span class="line"><span class="cl"><span class="c1">//	data	见DocumentIndexData注释
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// 注意：
</span></span></span><span class="line"><span class="cl"><span class="c1">//      1. 这个函数是线程安全的，请尽可能并发调用以提高索引速度
</span></span></span><span class="line"><span class="cl"><span class="c1">// 	2. 这个函数调用是非同步的，也就是说在函数返回时有可能文档还没有加入索引中，因此
</span></span></span><span class="line"><span class="cl"><span class="c1">//         如果立刻调用Search可能无法查询到这个文档。强制刷新索引请调用FlushIndex函数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">IndexDocument</span><span class="p">(</span><span class="nx">docId</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">data</span> <span class="nx">types</span><span class="p">.</span><span class="nx">DocumentIndexData</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nf">internalIndexDocument</span><span class="p">(</span><span class="nx">docId</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">murmur</span><span class="p">.</span><span class="nf">Murmur3</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">docId</span><span class="p">)))</span> <span class="o">%</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">PersistentStorageShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">UsePersistentStorage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">persistentStorageIndexDocumentChannels</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">persistentStorageIndexDocumentRequest</span><span class="p">{</span><span class="nx">docId</span><span class="p">:</span> <span class="nx">docId</span><span class="p">,</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">data</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">internalIndexDocument</span><span class="p">(</span><span class="nx">docId</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">data</span> <span class="nx">types</span><span class="p">.</span><span class="nx">DocumentIndexData</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">engine</span><span class="p">.</span><span class="nx">initialized</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;必须先初始化引擎&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">engine</span><span class="p">.</span><span class="nx">numIndexingRequests</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">murmur</span><span class="p">.</span><span class="nf">Murmur3</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="s">&#34;%d%s&#34;</span><span class="p">,</span> <span class="nx">docId</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">Content</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">engine</span><span class="p">.</span><span class="nx">segmenterChannel</span> <span class="o">&lt;-</span> <span class="nx">segmenterRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">docId</span><span class="p">:</span> <span class="nx">docId</span><span class="p">,</span> <span class="nx">hash</span><span class="p">:</span> <span class="nx">hash</span><span class="p">,</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">data</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里需要注意的是，docId参数需要调用者从外部传入，而不是在内部自己创建，这给搜索引擎的实现者更大的自由。
将文档交给分词器处理，然后根据murmur3计算的hash值模<code>PersistentStorageShards</code>，选择合适的<code>shard</code>写入持久化存储中。</p>
<h3 id="索引过程分析分词协程处理过程">索引过程分析：分词协程处理过程</h3>
<p>分词器协程的逻辑代码在这里：<code>segmenter_worker.go:func (engine *Engine) segmenterWorker()</code></p>
<p>分词器协程的逻辑是一个死循环，不停的从<code>channel engine.segmenterChannel</code>中读取数据，针对每一次读取的数据：</p>
<ol>
<li>计算<code>shard</code>号</li>
<li>将文档分词</li>
<li>根据分词结果，构造<code>indexerAddDocumentRequest</code> 和 <code>rankerAddDocRequest</code></li>
<li>将<code>indexerAddDocumentRequest</code>投递到<code>channel engine.indexerAddDocumentChannels[shard]</code>中</li>
<li>将<code>rankerAddDocRequest</code>投递到<code>channel engine.rankerAddDocChannels[shard]</code>中</li>
</ol>
<p>补充一句：这里<code>shard</code>号的计算过程如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 从文本hash得到要分配到的shard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">getShard</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">hash</span> <span class="o">-</span> <span class="nx">hash</span><span class="o">/</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span><span class="o">*</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为什么不是直接取模呢？</p>
<h3 id="索引过程分析索引器协程处理过程">索引过程分析：索引器协程处理过程</h3>
<p>首先介绍一下倒排索引表，这是搜索引擎的核心数据结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 索引器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Indexer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 从搜索键到文档列表的反向索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 加了读写锁以保证读写安全
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tableLock</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">		<span class="nx">table</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">KeywordIndices</span>
</span></span><span class="line"><span class="cl">		<span class="nx">docs</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">initOptions</span> <span class="nx">types</span><span class="p">.</span><span class="nx">IndexerInitOptions</span>
</span></span><span class="line"><span class="cl">	<span class="nx">initialized</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 这实际上是总文档数的一个近似
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">numDocuments</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 所有被索引文本的总关键词数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">totalTokenLength</span> <span class="kt">float32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 每个文档的关键词长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">docTokenLengths</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">float32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 反向索引表的一行，收集了一个搜索键出现的所有文档，按照DocId从小到大排序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">KeywordIndices</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 下面的切片是否为空，取决于初始化时IndexType的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">docIds</span>      <span class="p">[]</span><span class="kt">uint64</span>  <span class="c1">// 全部类型都有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">frequencies</span> <span class="p">[]</span><span class="kt">float32</span> <span class="c1">// IndexType == FrequenciesIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">locations</span>   <span class="p">[][]</span><span class="kt">int</span>   <span class="c1">// IndexType == LocationsIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>table map[string]*KeywordIndices</code>这个是核心：一个关键词，对应一个<code>KeywordIndices</code>结构。该结构的<code>docIds</code>字段记录了所有包含这个关键词的文档id。
如果 IndexType == FrequenciesIndex ，则同时记录这个关键词在该文档中出现次数。
如果 IndexType == LocationsIndex ，则同时记录这个关键词在该文档中出现的所有位置的起始偏移。</p>
<p>下面是索引的主函数代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">indexerAddDocumentWorker</span><span class="p">(</span><span class="nx">shard</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">request</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">engine</span><span class="p">.</span><span class="nx">indexerAddDocumentChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexers</span><span class="p">[</span><span class="nx">shard</span><span class="p">].</span><span class="nf">AddDocument</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">document</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">engine</span><span class="p">.</span><span class="nx">numTokenIndexAdded</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">document</span><span class="p">.</span><span class="nx">Keywords</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">engine</span><span class="p">.</span><span class="nx">numDocumentsIndexed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其主要逻辑又封装在<code>func (indexer *Indexer) AddDocument(document *types.DocumentIndex)</code>函数中实现。其逻辑如下：</p>
<ol>
<li>将倒排索引表加锁</li>
<li>更新文档关键词的长度加在一起的总和</li>
<li>查找关键词在倒排索引表中是否存在</li>
<li>如果不存在，则直接加入到<code>table map[string]*KeywordIndices</code>中</li>
<li>如果存在<code>KeywordIndices</code>，则使用二分查找该关键词对应的docId是否已经在<code>KeywordIndices.docIds</code>中存在。分两种情况：
<ol>
<li>docId存在，则更新原有的数据结构。</li>
<li>docId不存在，则插入到<code>KeywordIndices.docIds</code>数组中，同时保持升序排列。</li>
</ol>
</li>
<li>更新索引过的文章总数</li>
</ol>
<h3 id="索引过程分析排序器协程处理过程">索引过程分析：排序器协程处理过程</h3>
<p>在新索引文档的过程，排序器的主逻辑如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">rankerAddDocWorker</span><span class="p">(</span><span class="nx">shard</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">request</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">engine</span><span class="p">.</span><span class="nx">rankerAddDocChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">rankers</span><span class="p">[</span><span class="nx">shard</span><span class="p">].</span><span class="nf">AddDoc</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">docId</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>进而调用下面的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 给某个文档添加评分字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ranker</span> <span class="o">*</span><span class="nx">Ranker</span><span class="p">)</span> <span class="nf">AddDoc</span><span class="p">(</span><span class="nx">docId</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">fields</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ranker</span><span class="p">.</span><span class="nx">initialized</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;排序器尚未初始化&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ranker</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ranker</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">fields</span><span class="p">[</span><span class="nx">docId</span><span class="p">]</span> <span class="p">=</span> <span class="nx">fields</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ranker</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nx">docs</span><span class="p">[</span><span class="nx">docId</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ranker</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上述函数非常简单，只是将应用层自定义的数据加入到ranker中。</p>
<p>至此索引过程就完成了。简单来讲就是下面两个过程：</p>
<ol>
<li>将文档分词，得到一堆关键词</li>
<li>将 关键词-&gt;docId 的对应关系加入到全局的map中(实际上是分了多个shard)</li>
</ol>
<h2 id="搜索过程分析">搜索过程分析</h2>
<p>下面我们来分析一下搜索的过程。首先构造一个<code>SearchRequest</code>对象。一般情况下只需提供<code>SearchRequest.Text</code>即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 搜索的短语（必须是UTF-8格式），会被分词
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 当值为空字符串时关键词会从下面的Tokens读入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Text</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 关键词（必须是UTF-8格式），当Text不为空时优先使用Text
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 通常你不需要自己指定关键词，除非你运行自己的分词程序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Tokens</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 文档标签（必须是UTF-8格式），标签不存在文档文本中，但也属于搜索键的一种
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Labels</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 当不为nil时，仅从这些DocIds包含的键中搜索（忽略值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">DocIds</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 排序选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">RankOptions</span> <span class="o">*</span><span class="nx">RankOptions</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 超时，单位毫秒（千分之一秒）。此值小于等于零时不设超时。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 搜索超时的情况下仍有可能返回部分排序结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Timeout</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 设为true时仅统计搜索到的文档个数，不返回具体的文档
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">CountDocsOnly</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 不排序，对于可在引擎外部（比如客户端）排序情况适用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 对返回文档很多的情况打开此选项可以有效节省时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Orderless</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从本文一开始那段示例代码的搜索语句读起：<code>searcher.Search(types.SearchRequest{Text:&quot;百度中国&quot;})</code>。进入到 Search 函数内部，其逻辑如下：</p>
<h3 id="设置一些搜索选项">设置一些搜索选项</h3>
<p>例如排序选项<code>RankOptions</code>, 分数计算条件<code>ScoringCriteria</code>等等</p>
<h3 id="将搜索词进行分词">将搜索词进行分词</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// 收集关键词
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tokens</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">request</span><span class="p">.</span><span class="nx">Text</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">querySegments</span> <span class="o">:=</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">segmenter</span><span class="p">.</span><span class="nf">Segment</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">Text</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">querySegments</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">token</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Text</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">engine</span><span class="p">.</span><span class="nx">stopTokens</span><span class="p">.</span><span class="nf">IsStopToken</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">tokens</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Token</span><span class="p">().</span><span class="nf">Text</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">request</span><span class="p">.</span><span class="nx">Tokens</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">tokens</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tokens</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>这里的&quot;百度中国&quot;会分词得到两个词：<code>百度</code> 和<code>中国</code></p>
<h3 id="向索引器发送查找请求">向索引器发送查找请求</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// 建立排序器返回的通信通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rankerReturnChannel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="kd">chan</span> <span class="nx">rankerReturnRequest</span><span class="p">,</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 生成查找请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lookupRequest</span> <span class="o">:=</span> <span class="nx">indexerLookupRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">countDocsOnly</span><span class="p">:</span>       <span class="nx">request</span><span class="p">.</span><span class="nx">CountDocsOnly</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tokens</span><span class="p">:</span>              <span class="nx">tokens</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">labels</span><span class="p">:</span>              <span class="nx">request</span><span class="p">.</span><span class="nx">Labels</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">docIds</span><span class="p">:</span>              <span class="nx">request</span><span class="p">.</span><span class="nx">DocIds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">options</span><span class="p">:</span>             <span class="nx">rankOptions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rankerReturnChannel</span><span class="p">:</span> <span class="nx">rankerReturnChannel</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">orderless</span><span class="p">:</span>           <span class="nx">request</span><span class="p">.</span><span class="nx">Orderless</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 向索引器发送查找请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">shard</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">shard</span> <span class="p">&lt;</span> <span class="nx">engine</span><span class="p">.</span><span class="nx">initOptions</span><span class="p">.</span><span class="nx">NumShards</span><span class="p">;</span> <span class="nx">shard</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">.</span><span class="nx">indexerLookupChannels</span><span class="p">[</span><span class="nx">shard</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nx">lookupRequest</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>这里是否可以进行优化？ 1) 只向特定的shard分发请求，避免无谓的indexer查找过程。2) <code>rankerReturnChannel</code>是否不用每次都创建新的？</p>
<h3 id="读取索引器的返回结果然后排序">读取索引器的返回结果然后排序</h3>
<p>上面已经建立了结果的返回通道<code>rankerReturnChannel</code>，直接从个<code>channel</code>中读取返回数据，并加入到数组<code>rankOutput</code>中。
注意，如果设置了超时，就在超时之前能读取多少就读多少。
然后调用排序算法进行排序。排序算法直接调用Golang自带的<code>sort</code>包的排序算法。</p>
<p>下面我们深入到索引器，看看索引器是如何进行搜索的。其核心代码在这里<code>func (engine *Engine) indexerLookupWorker(shard int)</code>，它的主逻辑是一个死循环，不断的从<code>engine.indexerLookupChannels[shard]</code>读取搜索请求。</p>
<p>针对每一个搜索请求，会将请求分发到索引器去，调用<code>func (indexer *Indexer) Lookup(tokens []string, labels []string, docIds map[uint64]bool, countDocsOnly bool) (docs []types.IndexedDocument, numDocs int)</code>方法。其主要逻辑如下：</p>
<ol>
<li>将分词和标签合并在一起进行搜索</li>
<li>合并搜索到的docId，并进行初步排序，将docId大的排在前面(实际上是认为docId越大，时间越近，时效性越好)</li>
<li>然后进行排序，BM25算法</li>
<li>最后返回数据</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="https://github.com/huichen/wukong">悟空搜索引擎项目源码：https://github.com/huichen/wukong</a></li>
<li><a href="https://github.com/huichen/wukong/blob/master/docs/codelab.md">悟空引擎入门教程</a></li>
<li><a href="https://ayende.com/blog/171745/code-reading-wukong-full-text-search-engine">Code reading: Wukong full-text search engine</a></li>
</ol>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="http://blog.codeg.cn/2016/01/27/double-buffering/" data-toggle="tooltip" data-placement="top" title="应用双缓冲技术完美解决资源数据优雅无损的热加载问题">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="http://blog.codeg.cn/2016/02/05/influxdb-grafana/" data-toggle="tooltip" data-placement="top" title="使用grafana&#43;influxdb搭建炫酷的实时可视化监控平台">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    
                    
                    
                    

		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; CodeG Blog 2024
                    
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
