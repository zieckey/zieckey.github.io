<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.89.4" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>evpp设计细节系列(1)：利用 enable_shared_from_this 实现一个自管理的定时器 &middot; CodeG Blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://zieckey.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://zieckey.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://zieckey.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://zieckey.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://zieckey.github.io/"><h1>CodeG Blog</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://zieckey.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>evpp设计细节系列(1)：利用 enable_shared_from_this 实现一个自管理的定时器</h1>
  <time datetime=2017-04-19T10:11:01Z class="post-date">Wed, Apr 19, 2017</time>
  <h1 id="0-前言">0. 前言</h1>
<p><a href="https://github.com/Qihoo360/evpp">https://github.com/Qihoo360/evpp</a>是一个高性能的Reactor模式的现代化的C++11版本的高性能网络库。该项目中有一个<code>InvokeTimer</code>对象，接口头文件详细代码请参见<a href="https://github.com/Qihoo360/evpp/blob/master/evpp/invoke_timer.h">https://github.com/Qihoo360/evpp/blob/master/evpp/invoke_timer.h</a>。它是一个能自我管理的定时器类，可以将一个仿函数绑定到该定时器上，然后让该定时器自己管理并在预期的一段时间后执行该仿函数。</p>
<p>现在我们复盘一下这个功能的实现细节和演化过程。</p>
<h1 id="1-基础代码">1. 基础代码</h1>
<p>定时器原型声明可能是下面的样子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&amp;</span> f);
    <span style="color:#f92672">~</span>InvokeTimer();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Start</span>();
};
</code></pre></div><p>这个是最基本的接口，可以设置一个仿函数，并设置一个过期时间，然后绑定到一个<code>event_base</code>对象上，然后就可以期待过了一个预期的时间后，我们设置的仿函数被调用了。</p>
<p>为了便于说明后续的多个版本的实现，我们先将基础的不变的代码说明一下。</p>
<p>基础代码，我们采用<a href="https://github.com/Qihoo360/evpp">evpp</a>项目中的<code>TimerEventWatcher</code>，详细实现在这里<a href="https://github.com/Qihoo360/evpp/blob/master/evpp/event_watcher.h">event_watcher.h</a>和<a href="https://github.com/Qihoo360/evpp/blob/master/evpp/event_watcher.cc">event_watcher.cc</a>。它是一个时间定时器观察者对象，可以观察一个时间事件。</p>
<p>头文件<code>event_watcher.h</code>定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#pragma once
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span>;

<span style="color:#66d9ef">namespace</span> recipes {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventWatcher</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> Handler;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>EventWatcher();
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Init</span>();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Cancel</span>();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SetCancelCallback</span>(<span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> cb);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ClearHandler</span>() { handler_ <span style="color:#f92672">=</span> Handler(); }
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    EventWatcher(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evbase, <span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> handler);
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Watch</span>(<span style="color:#66d9ef">double</span> timeout_ms);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Close</span>();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FreeEvent</span>();

    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DoInit</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DoClose</span>() {}

<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event</span><span style="color:#f92672">*</span> event_;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evbase_;
    <span style="color:#66d9ef">bool</span> attached_;
    Handler handler_;
    Handler cancel_callback_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimerEventWatcher</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> EventWatcher {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    TimerEventWatcher(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evbase, <span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> handler, <span style="color:#66d9ef">double</span> timeout_ms);

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">AsyncWait</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> DoInit();
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HandlerFn</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">short</span> which, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> v);
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">double</span> timeout_ms_;
};

}

</code></pre></div><p>实现文件<code>event_watcher.cc</code>如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event_struct.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event_compat.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> recipes {

EventWatcher<span style="color:#f92672">::</span>EventWatcher(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evbase, <span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> handler)
    <span style="color:#f92672">:</span> evbase_(evbase), attached_(false), handler_(handler) {
    event_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> event;
    memset(event_, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event</span>));
}

EventWatcher<span style="color:#f92672">::~</span>EventWatcher() {
    FreeEvent();
    Close();
}

<span style="color:#66d9ef">bool</span> EventWatcher<span style="color:#f92672">::</span>Init() {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DoInit()) {
        <span style="color:#66d9ef">goto</span> failed;
    }

    <span style="color:#f92672">::</span>event_base_set(evbase_, event_);
    <span style="color:#66d9ef">return</span> true;

failed:
    Close();
    <span style="color:#66d9ef">return</span> false;
}


<span style="color:#66d9ef">void</span> EventWatcher<span style="color:#f92672">::</span>Close() {
    DoClose();
}

<span style="color:#66d9ef">bool</span> EventWatcher<span style="color:#f92672">::</span>Watch(<span style="color:#66d9ef">double</span> timeout_ms) {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span> tv;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">timeval</span><span style="color:#f92672">*</span> timeoutval <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">if</span> (timeout_ms <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        tv.tv_sec <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span>(timeout_ms <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000</span>);
        tv.tv_usec <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span>(timeout_ms <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000.0</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">1000</span>;
        timeoutval <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>tv;
    }

    <span style="color:#66d9ef">if</span> (attached_) {
        <span style="color:#75715e">// When InvokerTimer::periodic_ == true, EventWatcher::Watch will be called many times
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// so we need to remove it from event_base before we add it into event_base
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (event_del(event_) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;event_del failed. fd=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>event_<span style="color:#f92672">-&gt;</span>ev_fd <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; event_=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> event_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
            <span style="color:#75715e">// TODO how to deal with it when failed?
</span><span style="color:#75715e"></span>        }
        attached_ <span style="color:#f92672">=</span> false;
    }

    assert(<span style="color:#f92672">!</span>attached_);
    <span style="color:#66d9ef">if</span> (event_add(event_, timeoutval) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
        std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;event_add failed. fd=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>event_<span style="color:#f92672">-&gt;</span>ev_fd <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; event_=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> event_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        <span style="color:#66d9ef">return</span> false;
    }
    attached_ <span style="color:#f92672">=</span> true;
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">void</span> EventWatcher<span style="color:#f92672">::</span>FreeEvent() {
    <span style="color:#66d9ef">if</span> (event_) {
        <span style="color:#66d9ef">if</span> (attached_) {
            event_del(event_);
            attached_ <span style="color:#f92672">=</span> false;
        }

        <span style="color:#66d9ef">delete</span> (event_);
        event_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    }
}

<span style="color:#66d9ef">void</span> EventWatcher<span style="color:#f92672">::</span>Cancel() {
    assert(event_);
    FreeEvent();

    <span style="color:#66d9ef">if</span> (cancel_callback_) {
        cancel_callback_();
        cancel_callback_ <span style="color:#f92672">=</span> Handler();
    }
}

<span style="color:#66d9ef">void</span> EventWatcher<span style="color:#f92672">::</span>SetCancelCallback(<span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> cb) {
    cancel_callback_ <span style="color:#f92672">=</span> cb;
}


TimerEventWatcher<span style="color:#f92672">::</span>TimerEventWatcher(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evbase,
                                     <span style="color:#66d9ef">const</span> Handler<span style="color:#f92672">&amp;</span> handler,
                                     <span style="color:#66d9ef">double</span> timeout_ms)
    <span style="color:#f92672">:</span> EventWatcher(evbase, handler)
    , timeout_ms_(timeout_ms) {}

<span style="color:#66d9ef">bool</span> TimerEventWatcher<span style="color:#f92672">::</span>DoInit() {
    <span style="color:#f92672">::</span>event_set(event_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, TimerEventWatcher<span style="color:#f92672">::</span>HandlerFn, <span style="color:#66d9ef">this</span>);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">void</span> TimerEventWatcher<span style="color:#f92672">::</span>HandlerFn(<span style="color:#66d9ef">int</span> <span style="color:#75715e">/*fd*/</span>, <span style="color:#66d9ef">short</span> <span style="color:#75715e">/*which*/</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> v) {
    TimerEventWatcher<span style="color:#f92672">*</span> h <span style="color:#f92672">=</span> (TimerEventWatcher<span style="color:#f92672">*</span>)v;
    h<span style="color:#f92672">-&gt;</span>handler_();
}

<span style="color:#66d9ef">bool</span> TimerEventWatcher<span style="color:#f92672">::</span>AsyncWait() {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Watch</span>(timeout_ms_);
}

}

</code></pre></div><h1 id="2-一个最基本的实现basic-01">2. 一个最基本的实现：basic-01</h1>
<p>我们先尝试实现一个能满足最基本需求的定时器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 头文件
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span>;

<span style="color:#66d9ef">namespace</span> recipes {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimerEventWatcher</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> Functor;

    InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f);
    <span style="color:#f92672">~</span>InvokeTimer();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Start</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> OnTimerTriggered();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> loop_;
    <span style="color:#66d9ef">double</span> timeout_ms_;
    Functor functor_;
    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TimerEventWatcher<span style="color:#f92672">&gt;</span> timer_;
};

}



<span style="color:#75715e">// 实现文件
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> recipes {

InvokeTimer<span style="color:#f92672">::</span>InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f)
    <span style="color:#f92672">:</span> loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

InvokeTimer<span style="color:#f92672">::~</span>InvokeTimer() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::~InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>Start() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    timer_.reset(<span style="color:#66d9ef">new</span> TimerEventWatcher(loop_, std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered, <span style="color:#66d9ef">this</span>), timeout_ms_));
    timer_<span style="color:#f92672">-&gt;</span>Init();
    timer_<span style="color:#f92672">-&gt;</span>AsyncWait();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start(AsyncWait) tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timer=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timer_.get() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timeout(ms)=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timeout_ms_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::OnTimerTriggered tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    functor_();
    functor_ <span style="color:#f92672">=</span> Functor();
}

}


</code></pre></div><p>测试main.cc</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;winmain-inl.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> __FUNCTION__ <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; hello world.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> base <span style="color:#f92672">=</span> event_base_new();
    <span style="color:#66d9ef">auto</span> timer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> recipes<span style="color:#f92672">::</span>InvokeTimer(base, <span style="color:#ae81ff">1000.0</span>, <span style="color:#f92672">&amp;</span>Print);
    timer<span style="color:#f92672">-&gt;</span>Start();
    event_base_dispatch(base);
    event_base_free(base);
    <span style="color:#66d9ef">delete</span> timer;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>我们先创建一个<code>event_base</code>对象，随后创建一个<code>InvokeTimer</code>对象，随后让timer启动起来，即将timer注册到<code>event_base</code>对象中，最后运行<code>event_base_dispatch(base)</code>。</p>
<p>下面编译运行，结果是符合预期的：当timer的时间到期后，能顺利触发回调。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ls -l
total <span style="color:#ae81ff">80</span>
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili  <span style="color:#ae81ff">2729</span> Apr <span style="color:#ae81ff">15</span> 20:39 event_watcher.cc
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">996</span> Apr <span style="color:#ae81ff">15</span> 20:39 event_watcher.h
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili  <span style="color:#ae81ff">1204</span> Apr <span style="color:#ae81ff">14</span> 10:55 invoke_timer.cc
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">805</span> Apr <span style="color:#ae81ff">14</span> 10:55 invoke_timer.h
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">374</span> Apr <span style="color:#ae81ff">14</span> 10:55 main.cc
$ g++ -std<span style="color:#f92672">=</span>c++11 event_watcher.cc invoke_timer.cc main.cc -levent
$ ./a.out
InvokeTimer::InvokeTimer tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
InvokeTimer::Start tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
InvokeTimer::Start<span style="color:#f92672">(</span>AsyncWait<span style="color:#f92672">)</span> tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> timer<span style="color:#f92672">=</span>0x14504c0 this<span style="color:#f92672">=</span>0x7ffd2790f780 timeout<span style="color:#f92672">(</span>ms<span style="color:#f92672">)=</span><span style="color:#ae81ff">1000</span>
InvokeTimer::OnTimerTriggered tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
Print hello world.
InvokeTimer::~InvokeTimer tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
</code></pre></div><p>这个实现方式，<code>InvokeTimer</code>对象生命周期的管理是一个问题，它需要调用者自己管理。</p>
<h1 id="3-能够实现最基本自我管理basic-02">3. 能够实现最基本自我管理：basic-02</h1>
<p>为了实现<code>InvokeTimer</code>对象生命周期的自我管理，其实就是调用者不需要关心<code>InvokeTimer</code>对象的生命周期问题。可以设想一下，假如<code>InvokeTimer</code>对象创建后，当定时时间一到，我们就调用其绑定的毁掉回函，然后<code>InvokeTimer</code>对象自我销毁，是不是就可以实现自我管理了呢？嗯，这个可行。请看下面代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 头文件
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span>;

<span style="color:#66d9ef">namespace</span> recipes {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimerEventWatcher</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> Functor;

    <span style="color:#66d9ef">static</span> InvokeTimer<span style="color:#f92672">*</span> <span style="color:#a6e22e">Create</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop,
                                 <span style="color:#66d9ef">double</span> timeout_ms,
                                 <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f);

    <span style="color:#f92672">~</span>InvokeTimer();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Start</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OnTimerTriggered</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> loop_;
    <span style="color:#66d9ef">double</span> timeout_ms_;
    Functor functor_;
    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TimerEventWatcher<span style="color:#f92672">&gt;</span> timer_;
};

}


<span style="color:#75715e">// 实现文件
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> recipes {

InvokeTimer<span style="color:#f92672">::</span>InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f)
    <span style="color:#f92672">:</span> loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

InvokeTimer<span style="color:#f92672">*</span> InvokeTimer<span style="color:#f92672">::</span>Create(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">InvokeTimer</span>(evloop, timeout_ms, f);
}

InvokeTimer<span style="color:#f92672">::~</span>InvokeTimer() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::~InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>Start() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    timer_.reset(<span style="color:#66d9ef">new</span> TimerEventWatcher(loop_, std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered, <span style="color:#66d9ef">this</span>), timeout_ms_));
    timer_<span style="color:#f92672">-&gt;</span>Init();
    timer_<span style="color:#f92672">-&gt;</span>AsyncWait();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start(AsyncWait) tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timer=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timer_.get() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timeout(ms)=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timeout_ms_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::OnTimerTriggered tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    functor_();
    functor_ <span style="color:#f92672">=</span> Functor();
    <span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">this</span>;
}

}

</code></pre></div><p>请注意，上述实现中，为了实现自我销毁，我们必须调用 <strong>delete</strong> ，这就注定了<code>InvokeTimer</code>对象必须在堆上创建，因此我们隐藏了它的构造函数，然后用一个静态的 <strong>Create</strong> 成员来创建<code>InvokeTimer</code>对象的实例。</p>
<p>相应的，<code>main.cc</code>也做了一点点修改代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;winmain-inl.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> __FUNCTION__ <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; hello world.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> base <span style="color:#f92672">=</span> event_base_new();
    <span style="color:#66d9ef">auto</span> timer <span style="color:#f92672">=</span> recipes<span style="color:#f92672">::</span>InvokeTimer<span style="color:#f92672">::</span>Create(base, <span style="color:#ae81ff">1000.0</span>, <span style="color:#f92672">&amp;</span>Print);
    timer<span style="color:#f92672">-&gt;</span>Start(); <span style="color:#75715e">// 启动完成后，就不用关注该对象了
</span><span style="color:#75715e"></span>    event_base_dispatch(base);
    event_base_free(base);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>这个实现，就不需要上层调用者手工<code>delete</code>这个<code>InvokeTimer</code>对象的实例，从而达到<code>InvokeTimer</code>对象自我管理的目的。</p>
<p>下面编译运行，结果是符合预期的：当timer时间到期后，能顺利触发回调，并且<code>InvokeTimer</code>对象也自动析构了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ls -l
total <span style="color:#ae81ff">80</span>
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili  <span style="color:#ae81ff">2729</span> Apr <span style="color:#ae81ff">15</span> 20:39 event_watcher.cc
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">996</span> Apr <span style="color:#ae81ff">15</span> 20:39 event_watcher.h
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili  <span style="color:#ae81ff">1204</span> Apr <span style="color:#ae81ff">14</span> 10:55 invoke_timer.cc
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">805</span> Apr <span style="color:#ae81ff">14</span> 10:55 invoke_timer.h
-rw-rw-r-- <span style="color:#ae81ff">1</span> weizili weizili   <span style="color:#ae81ff">374</span> Apr <span style="color:#ae81ff">14</span> 10:55 main.cc
$ g++ -std<span style="color:#f92672">=</span>c++11 event_watcher.cc invoke_timer.cc main.cc -levent
$ ./a.out
InvokeTimer::InvokeTimer tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
InvokeTimer::Start tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
InvokeTimer::Start<span style="color:#f92672">(</span>AsyncWait<span style="color:#f92672">)</span> tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> timer<span style="color:#f92672">=</span>0x14504c0 this<span style="color:#f92672">=</span>0x7ffd2790f780 timeout<span style="color:#f92672">(</span>ms<span style="color:#f92672">)=</span><span style="color:#ae81ff">1000</span>
InvokeTimer::OnTimerTriggered tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
Print hello world.
InvokeTimer::~InvokeTimer tid<span style="color:#f92672">=</span><span style="color:#ae81ff">139965845526336</span> this<span style="color:#f92672">=</span>0x7ffd2790f780
</code></pre></div><h1 id="4-如果要取消一个定时器怎么办cancel-03">4. 如果要取消一个定时器怎么办：cancel-03</h1>
<p>上面第2种实现方式，实现了定时器的自我管理，调用者不需要关心定时器的生命周期的管理问题。接下来，新的需求又来了，上层调用者说，在对外发起一个请求时，可以设置一个定时器来处理超时问题，但如果请求及时的回来了，我们得及时取消该定时器啊，这又如何处理呢？</p>
<p>这就相当于要把上层调用者还得一直保留<code>InvokeTimer</code>对象的实例，以便在需要的时候，提前取消掉该定时器。上层调用者保留这个指针，就会带来一定的风险，例如误用，当<code>InvokeTimer</code>对象已经自动析构了，该该指针还继续存在于上层调用者那里。</p>
<p>于是乎，智能指针<code>shared_ptr</code>出场了，我们希望上层调用者看到的对象是以<code>shared_ptr&lt;InvokeTimer&gt;</code>形式存在的，无论上层调用者是否保留这个<code>shared_ptr&lt;InvokeTimer&gt;</code>对象，<code>InvokeTimer</code>对象都能自我管理，也就是说，当上层调用者不保留<code>shared_ptr&lt;InvokeTimer&gt;</code>对象时，<code>InvokeTimer</code>对象要能自我管理。</p>
<p>这里就必须让<code>InvokeTimer</code>对象本身也要保存一份<code>shared_ptr&lt;InvokeTimer&gt;</code>对象。为了实现这一技术，我们需要引入<code>enable_shared_from_this</code>。关于<code>enable_shared_from_this</code>的介绍，网络上已经有很多资料了，这里不多累述。我们直接上最终的实现代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 头文件
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span>;

<span style="color:#66d9ef">namespace</span> recipes {

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimerEventWatcher</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span>;

<span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>InvokeTimer<span style="color:#f92672">&gt;</span> InvokeTimerPtr;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InvokeTimer</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>enable_shared_from_this<span style="color:#f92672">&lt;</span>InvokeTimer<span style="color:#f92672">&gt;</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> Functor;

    <span style="color:#66d9ef">static</span> InvokeTimerPtr <span style="color:#a6e22e">Create</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop,
                                 <span style="color:#66d9ef">double</span> timeout_ms,
                                 <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f);

    <span style="color:#f92672">~</span>InvokeTimer();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Start</span>();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Cancel</span>();

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_cancel_callback</span>(<span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> fn) {
        cancel_callback_ <span style="color:#f92672">=</span> fn;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OnTimerTriggered</span>();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">OnCanceled</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> loop_;
    <span style="color:#66d9ef">double</span> timeout_ms_;
    Functor functor_;
    Functor cancel_callback_;
    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>TimerEventWatcher<span style="color:#f92672">&gt;</span> timer_;
    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>InvokeTimer<span style="color:#f92672">&gt;</span> self_; <span style="color:#75715e">// Hold myself
</span><span style="color:#75715e"></span>};

}


<span style="color:#75715e">// 实现文件
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> recipes {

InvokeTimer<span style="color:#f92672">::</span>InvokeTimer(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f)
    <span style="color:#f92672">:</span> loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

InvokeTimerPtr InvokeTimer<span style="color:#f92672">::</span>Create(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> evloop, <span style="color:#66d9ef">double</span> timeout_ms, <span style="color:#66d9ef">const</span> Functor<span style="color:#f92672">&amp;</span> f) {
    InvokeTimerPtr <span style="color:#a6e22e">it</span>(<span style="color:#66d9ef">new</span> InvokeTimer(evloop, timeout_ms, f));
    it<span style="color:#f92672">-&gt;</span>self_ <span style="color:#f92672">=</span> it;
    <span style="color:#66d9ef">return</span> it;
}

InvokeTimer<span style="color:#f92672">::~</span>InvokeTimer() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::~InvokeTimer tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>Start() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; refcount=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> self_.use_count() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    timer_.reset(<span style="color:#66d9ef">new</span> TimerEventWatcher(loop_, std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered, shared_from_this()), timeout_ms_));
    timer_<span style="color:#f92672">-&gt;</span>SetCancelCallback(std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>InvokeTimer<span style="color:#f92672">::</span>OnCanceled, shared_from_this()));
    timer_<span style="color:#f92672">-&gt;</span>Init();
    timer_<span style="color:#f92672">-&gt;</span>AsyncWait();
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::Start(AsyncWait) tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timer=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timer_.get() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; refcount=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> self_.use_count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; periodic=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> periodic_ <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timeout(ms)=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> timeout_ms_ <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>Cancel() {
    <span style="color:#66d9ef">if</span> (timer_) {
        timer_<span style="color:#f92672">-&gt;</span>Cancel();
    }
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>OnTimerTriggered() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::OnTimerTriggered tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; use_count=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> self_.use_count() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    functor_();
    functor_ <span style="color:#f92672">=</span> Functor();
    cancel_callback_ <span style="color:#f92672">=</span> Functor();
    timer_.reset();
    self_.reset();
}

<span style="color:#66d9ef">void</span> InvokeTimer<span style="color:#f92672">::</span>OnCanceled() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;InvokeTimer::OnCanceled tid=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; this=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; use_count=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> self_.use_count() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
    <span style="color:#66d9ef">if</span> (cancel_callback_) {
        cancel_callback_();
        cancel_callback_ <span style="color:#f92672">=</span> Functor();
    }
    functor_ <span style="color:#f92672">=</span> Functor();
    timer_.reset();
    self_.reset();
}

}


</code></pre></div><p>相应的，<code>main.cc</code>也做了一点点修改代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;winmain-inl.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> __FUNCTION__ <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; hello world.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> base <span style="color:#f92672">=</span> event_base_new();
    <span style="color:#66d9ef">auto</span> timer <span style="color:#f92672">=</span> recipes<span style="color:#f92672">::</span>InvokeTimer<span style="color:#f92672">::</span>Create(base, <span style="color:#ae81ff">1000.0</span>, <span style="color:#f92672">&amp;</span>Print);
    timer<span style="color:#f92672">-&gt;</span>Start(); <span style="color:#75715e">// 启动完成后，就不用关注该对象了
</span><span style="color:#75715e"></span>    event_base_dispatch(base);
    event_base_free(base);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>这个实现，就不需要上层调用者手工<code>delete</code>这个<code>InvokeTimer</code>对象的实例，从而达到<code>InvokeTimer</code>对象自我管理的目的。</p>
<p>下面编译运行，结果是符合预期的：当timer时间到期后，能顺利触发回调，并且<code>InvokeTimer</code>对象也自动析构了。</p>
<h1 id="5-实现一个周期性的定时器periodic-04">5. 实现一个周期性的定时器：periodic-04</h1>
<p>上述几个实现中，都是一次性的定时器任务。但是如果我们想实现一个周期性的定时器该如何实现呢？例如，我们有一个任务，需要每分钟做一次。</p>
<p>其实，基于上述第三个版本的实现，可以很容易的实现周期性的定时器功能。只需要在回调函数中，继续调用<code>timer-&gt;AsyncWait()</code>即可。详细的修改情况如下。</p>
<p>头文件 invoke_timer.h 改变：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">
<span style="color:#75715e">@@ -18,7 +18,8 @@ public:
</span><span style="color:#75715e"></span>
     static InvokeTimerPtr Create(struct event_base* evloop,
                                  double timeout_ms,
<span style="color:#f92672">-                                 const Functor&amp; f);
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                                 const Functor&amp; f,
</span><span style="color:#a6e22e">+                                 bool periodic);
</span><span style="color:#a6e22e"></span>
     ~InvokeTimer();

<span style="color:#75715e">@@ -30,7 +31,7 @@ public:
</span><span style="color:#75715e"></span>         cancel_callback_ = fn;
     }
 private:
<span style="color:#f92672">-    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp; f);
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+    InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp; f, bool periodic);
</span><span style="color:#a6e22e"></span>     void OnTimerTriggered();
     void OnCanceled();

<span style="color:#75715e">@@ -40,6 +41,7 @@ private:
</span><span style="color:#75715e"></span>     Functor functor_;
     Functor cancel_callback_;
     std::shared_ptr&lt;TimerEventWatcher&gt; timer_;
<span style="color:#a6e22e">+    bool periodic_;
</span><span style="color:#a6e22e"></span>     std::shared_ptr&lt;InvokeTimer&gt; self_; // Hold myself
 };
</code></pre></div><p>实现文件 invoke_timer.cc 改变：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">
 namespace recipes {

<span style="color:#f92672">-InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp; f)
</span><span style="color:#f92672">-    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f) {
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+InvokeTimer::InvokeTimer(struct event_base* evloop, double timeout_ms, const Functor&amp; f, bool periodic)
</span><span style="color:#a6e22e">+    : loop_(evloop), timeout_ms_(timeout_ms), functor_(f), periodic_(periodic) {
</span><span style="color:#a6e22e"></span>     std::cout &lt;&lt; &#34;InvokeTimer::InvokeTimer tid=&#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#34; this=&#34; &lt;&lt; this &lt;&lt; std::endl;
 }

<span style="color:#f92672">-InvokeTimerPtr InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp; f) {
</span><span style="color:#f92672">-    InvokeTimerPtr it(new InvokeTimer(evloop, timeout_ms, f));
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+InvokeTimerPtr InvokeTimer::Create(struct event_base* evloop, double timeout_ms, const Functor&amp; f, bool periodic) {
</span><span style="color:#a6e22e">+    InvokeTimerPtr it(new InvokeTimer(evloop, timeout_ms, f, periodic));
</span><span style="color:#a6e22e"></span>     it-&gt;self_ = it;
     return it;
 }
<span style="color:#75715e">@@ -27,7 +27,7 @@ void InvokeTimer::Start() {
</span><span style="color:#75715e"></span>     timer_-&gt;SetCancelCallback(std::bind(&amp;InvokeTimer::OnCanceled, shared_from_this()));
     timer_-&gt;Init();
     timer_-&gt;AsyncWait();
 }

 void InvokeTimer::Cancel() {
<span style="color:#75715e">@@ -39,14 +39,20 @@ void InvokeTimer::Cancel() {
</span><span style="color:#75715e"></span> void InvokeTimer::OnTimerTriggered() {
     std::cout &lt;&lt; &#34;InvokeTimer::OnTimerTriggered tid=&#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#34; this=&#34; &lt;&lt; this &lt;&lt; &#34; use_count=&#34; &lt;&lt; self_.use_count() &lt;&lt; std::endl;
     functor_();
<span style="color:#f92672">-    functor_ = Functor();
</span><span style="color:#f92672">-    cancel_callback_ = Functor();
</span><span style="color:#f92672">-    timer_.reset();
</span><span style="color:#f92672">-    self_.reset();
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+    if (periodic_) {
</span><span style="color:#a6e22e">+        timer_-&gt;AsyncWait();
</span><span style="color:#a6e22e">+    } else {
</span><span style="color:#a6e22e">+        functor_ = Functor();
</span><span style="color:#a6e22e">+        cancel_callback_ = Functor();
</span><span style="color:#a6e22e">+        timer_.reset();
</span><span style="color:#a6e22e">+        self_.reset();
</span><span style="color:#a6e22e">+    }
</span><span style="color:#a6e22e"></span> }

 void InvokeTimer::OnCanceled() {
     std::cout &lt;&lt; &#34;InvokeTimer::OnCanceled tid=&#34; &lt;&lt; std::this_thread::get_id() &lt;&lt; &#34; this=&#34; &lt;&lt; this &lt;&lt; &#34; use_count=&#34; &lt;&lt; self_.use_count() &lt;&lt; std::endl;
<span style="color:#a6e22e">+    periodic_ = false;
</span><span style="color:#a6e22e"></span>     if (cancel_callback_) {
         cancel_callback_();
         cancel_callback_ = Functor();

</code></pre></div><p>main.cc测试示例代码也有所修改，具体如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;invoke_timer.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;event_watcher.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;winmain-inl.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;event2/event.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> __FUNCTION__ <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; hello world.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event_base</span><span style="color:#f92672">*</span> base <span style="color:#f92672">=</span> event_base_new();
    <span style="color:#66d9ef">auto</span> timer <span style="color:#f92672">=</span> recipes<span style="color:#f92672">::</span>InvokeTimer<span style="color:#f92672">::</span>Create(base, <span style="color:#ae81ff">1000.0</span>, <span style="color:#f92672">&amp;</span>Print, true);
    timer<span style="color:#f92672">-&gt;</span>Start();
    timer.reset();
    event_base_dispatch(base);
    event_base_free(base);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>该版本是最终的实现版本。相关代码都在<a href="https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer">https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer</a>这里，为了便于演示，其不依赖<a href="https://github.com/Qihoo360/evpp">evpp</a>。</p>
<h1 id="6-最后">6. 最后</h1>
<p><a href="https://github.com/Qihoo360/evpp">evpp</a>项目官网地址为：<a href="https://github.com/Qihoo360/evpp">https://github.com/Qihoo360/evpp</a>
本文中的详细代码实现请参考 <a href="https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer">https://github.com/Qihoo360/evpp/tree/master/examples/recipes/self_control_timer</a></p>
<h1 id="7-evpp系列文章列表">7. evpp系列文章列表</h1>
<p><a href="http://blog.csdn.net/zieckey/article/details/69803011">evpp性能测试（3）: 对无锁队列boost::lockfree::queue和moodycamel::ConcurrentQueue做一个性能对比测试</a>
<a href="http://blog.csdn.net/zieckey/article/details/69170619">evpp性能测试（2）: 与Boost.Asio进行吞吐量对比测试</a>
<a href="http://blog.csdn.net/zieckey/article/details/63778715">evpp性能测试（1）: 与muduo进行吞吐量测试</a>
<a href="http://blog.csdn.net/zieckey/article/details/63760757">发布一个高性能的Reactor模式的C++网络库：evpp</a></p>

</div>


    </main>

    
      
    
  </body>
</html>
