<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.89.4" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Nginx源码研究（6）——双向链表结构ngx_queue_t &middot; CodeG Blog</title>
  <meta name="description" content="本文主要介绍Nginx双向链表结构`ngx_queue_t`这一重要的数据结构的使用方法和具体实现。`ngx_queue_t` 是Nginx提供的一个轻量级双向链表容器，它不负责分配内存来存放链表元素。" />

  
  <link type="text/css" rel="stylesheet" href="http://blog.codeg.cncss/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://blog.codeg.cncss/poole.css">
  <link type="text/css" rel="stylesheet" href="http://blog.codeg.cncss/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://blog.codeg.cncss/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://blog.codeg.cn"><h1>CodeG Blog</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://blog.codeg.cn">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Nginx源码研究（6）——双向链表结构ngx_queue_t</h1>
  <time datetime=2015-01-04T00:00:00Z class="post-date">Sun, Jan 4, 2015</time>
  <h2 id="简介">简介</h2>
<p>本文主要介绍Nginx双向链表结构<code>ngx_queue_t</code>这一重要的数据结构的使用方法和具体实现。</p>
<p><code>ngx_queue_t</code> 是Nginx提供的一个轻量级双向链表容器，它不负责分配内存来存放链表元素。
其具备下列特点：</p>
<ul>
<li>可以高效的执行插入、删除、合并等操作</li>
<li>具有排序功能</li>
<li>支持两个链表间的合并</li>
<li>支持将一个链表一分为二的拆分动作</li>
</ul>
<p>不同于教科书中将链表节点的数据成员声明在链表节点的结构体中，<code>ngx_queue_t</code>只是声明了前向和后向指针。在使用的时候，我们首先需要定义一个哨兵节点(对于后续具体存放数据的节点，我们称之为数据节点)，比如：</p>
<pre><code>ngx_queue_t head;
</code></pre>
<p>接下来需要进行初始化，通过宏ngx_queue_init()来实现：</p>
<pre><code>ngx_queue_init(&amp;head);
</code></pre>
<p>ngx_queue_init()的宏定义如下：</p>
<pre><code>#define ngx_queue_init(q)     \
    (q)-&gt;prev = q;            \
    (q)-&gt;next = q;
</code></pre>
<p>可见初始的时候哨兵节点的 prev 和 next 都指向自己，因此其实是一个空链表。ngx_queue_empty()可以据此来判断一个链表是否为空。</p>
<h2 id="源代码位置">源代码位置</h2>
<p>src/core/ngx_queue.{h,c}</p>
<h2 id="源码分析">源码分析</h2>
<p>除了<code>ngx_queue_data</code>值得一说外，其他都是双向链表的基本操作，与教科书里的定义完全一致，不在累述。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//获取队列中节点数据， q是队列中的节点，type队列类型，field是队列类型中ngx_queue_t的元素名
</span><span style="color:#75715e"></span><span style="color:#75715e">#define ngx_queue_data(q, type, field)                                         \
</span><span style="color:#75715e">    (type *) ((u_char *) q - offsetof(type, field))
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//offsetof也是一个宏定义，如下：
</span><span style="color:#75715e"></span><span style="color:#75715e">#define offsetof(p_type,field) ((size_t)&amp;(((p_type *)0)-&gt;field))
</span></code></pre></div><h2 id="测试代码">测试代码</h2>
<p>该测试代码的完整工程的编译和运行方式请参考 <a href="https://github.com/zieckey/nginx-research">https://github.com/zieckey/nginx-research项目</a>。Linux&amp;Windows都测试通过。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;allinc.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>

namespace {
    <span style="color:#66d9ef">struct</span> QueueElement {
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name;
        <span style="color:#66d9ef">int</span> id;
        ngx_queue_t queue;
    };

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> ids[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span> };
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> names[] <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;codeg&#34;</span>, <span style="color:#e6db74">&#34;jane&#34;</span>, <span style="color:#e6db74">&#34;zieckey&#34;</span>, <span style="color:#e6db74">&#34;codeg4&#34;</span>, <span style="color:#e6db74">&#34;codeg5&#34;</span>, <span style="color:#e6db74">&#34;codeg6&#34;</span>, <span style="color:#e6db74">&#34;codeg7&#34;</span>, <span style="color:#e6db74">&#34;codeg8&#34;</span>, <span style="color:#e6db74">&#34;codeg9&#34;</span>, <span style="color:#e6db74">&#34;codeg10&#34;</span> };
}

<span style="color:#66d9ef">void</span> dump_queue_from_tail(ngx_queue_t <span style="color:#f92672">*</span>que)
{
    ngx_queue_t <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> ngx_queue_last(que);

    printf(<span style="color:#e6db74">&#34;(0x%p: (0x%p, 0x%p)) &lt;==&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, que, que<span style="color:#f92672">-&gt;</span>prev, que<span style="color:#f92672">-&gt;</span>next);

    <span style="color:#66d9ef">for</span> (; q <span style="color:#f92672">!=</span> ngx_queue_sentinel(que); q <span style="color:#f92672">=</span> ngx_queue_prev(q))
    {
        QueueElement <span style="color:#f92672">*</span>u <span style="color:#f92672">=</span> ngx_queue_data(q, QueueElement, queue);
        printf(<span style="color:#e6db74">&#34;(0x%p: (id=%d %s), 0x%p: (0x%p, 0x%p)) &lt;==&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, u, u<span style="color:#f92672">-&gt;</span>id,
            u<span style="color:#f92672">-&gt;</span>name, <span style="color:#f92672">&amp;</span>u<span style="color:#f92672">-&gt;</span>queue, u<span style="color:#f92672">-&gt;</span>queue.prev, u<span style="color:#f92672">-&gt;</span>queue.next);
    }
}

<span style="color:#66d9ef">void</span> dump_queue_from_head(ngx_queue_t <span style="color:#f92672">*</span>que)
{
    ngx_queue_t <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> ngx_queue_head(que);

    printf(<span style="color:#e6db74">&#34;(0x%x: (0x%x, 0x%x)) &lt;==&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, que, que<span style="color:#f92672">-&gt;</span>prev, que<span style="color:#f92672">-&gt;</span>next);

    <span style="color:#66d9ef">for</span> (; q <span style="color:#f92672">!=</span> ngx_queue_sentinel(que); q <span style="color:#f92672">=</span> ngx_queue_next(q))
    {
        QueueElement <span style="color:#f92672">*</span>u <span style="color:#f92672">=</span> ngx_queue_data(q, QueueElement, queue);
        printf(<span style="color:#e6db74">&#34;(0x%p: (id=%d %s), 0x%p: (0x%p, 0x%p)) &lt;==&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, u, u<span style="color:#f92672">-&gt;</span>id,
            u<span style="color:#f92672">-&gt;</span>name, <span style="color:#f92672">&amp;</span>u<span style="color:#f92672">-&gt;</span>queue, u<span style="color:#f92672">-&gt;</span>queue.prev, u<span style="color:#f92672">-&gt;</span>queue.next);
    }
}

<span style="color:#75715e">//sort from small to big  
</span><span style="color:#75715e"></span>ngx_int_t my_point_cmp(<span style="color:#66d9ef">const</span> ngx_queue_t<span style="color:#f92672">*</span> lhs, <span style="color:#66d9ef">const</span> ngx_queue_t<span style="color:#f92672">*</span> rhs)
{
    QueueElement <span style="color:#f92672">*</span>pt1 <span style="color:#f92672">=</span> ngx_queue_data(lhs, QueueElement, queue);
    QueueElement <span style="color:#f92672">*</span>pt2 <span style="color:#f92672">=</span> ngx_queue_data(rhs, QueueElement, queue);

    <span style="color:#66d9ef">if</span> (pt1<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">&lt;</span> pt2<span style="color:#f92672">-&gt;</span>id)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}

TEST_UNIT_P(ngx_queue)
{
    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;a new pool created:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    pool <span style="color:#f92672">=</span> ngx_create_pool(<span style="color:#ae81ff">1024</span>, NULL);
    dump_pool(pool);

    ngx_queue_t <span style="color:#f92672">*</span>myque;

    myque <span style="color:#f92672">=</span> (ngx_queue_t<span style="color:#f92672">*</span>)ngx_palloc(pool, <span style="color:#66d9ef">sizeof</span>(ngx_queue_t));  <span style="color:#75715e">//alloc a queue head  
</span><span style="color:#75715e"></span>    ngx_queue_init(myque);  <span style="color:#75715e">//init the queue  
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//insert  some points into the queue  
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)H_ARRAYSIZE(names); i<span style="color:#f92672">++</span>)
    {
        QueueElement <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> (QueueElement<span style="color:#f92672">*</span>)ngx_palloc(pool, <span style="color:#66d9ef">sizeof</span>(QueueElement));
        e<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">=</span> names[i];
        e<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">=</span> ids[i];
        ngx_queue_init(<span style="color:#f92672">&amp;</span>e<span style="color:#f92672">-&gt;</span>queue);

        <span style="color:#75715e">//insert this point into the points queue  
</span><span style="color:#75715e"></span>        ngx_queue_insert_head(myque, <span style="color:#f92672">&amp;</span>e<span style="color:#f92672">-&gt;</span>queue);
    }

    dump_queue_from_tail(myque);
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;sort the queue:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    ngx_queue_sort(myque, my_point_cmp);
    dump_queue_from_head(myque);
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;the pool at the end:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;--------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    dump_pool(pool);
}
</code></pre></div><p>上述例子运行到最后，排序之后的链表正好是升序排列，可以通过下面的调试截图来看到实际内存情况：</p>
<p><a href="/images/githubpages/nginx/ngx_queue_t.png"><img src="/images/githubpages/nginx/ngx_queue_t.png" alt=""></a></p>
<p>其中watch变量表达式为<code>(QueueElement*)((u_char *)myque-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next - (size_t)&amp;(((QueueElement *)0)-&gt;queue))</code></p>
<h2 id="参考">参考：</h2>
<ol>
<li><a href="http://tengine.taobao.org/book/chapter_02.html#ngx-queue-t-100">淘宝：Nginx开发从入门到精通 http://tengine.taobao.org/book/chapter_02.html#ngx-queue-t-100</a></li>
<li><a href="https://github.com/zieckey/nginx-1.0.14_comment/blob/master/src/core/ngx_queue.h">nginx源码注释 https://github.com/zieckey/nginx-1.0.14_comment/blob/master/src/core/ngx_queue.h</a></li>
<li><a href="https://github.com/zieckey/nginx-1.0.14_comment/blob/master/src/core/ngx_queue.c">nginx源码注释 https://github.com/zieckey/nginx-1.0.14_comment/blob/master/src/core/ngx_queue.c</a></li>
<li><a href="http://my.oschina.net/chenzhuo/blog/174868">nginx代码分析-基本结构-queue http://my.oschina.net/chenzhuo/blog/174868</a></li>
</ol>

</div>


    </main>

    
      
    
  </body>
</html>
