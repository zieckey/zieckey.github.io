<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quic on CodeG Blog</title>
    <link>http://blog.codeg.cn/tags/quic/</link>
    <description>Recent content in quic on CodeG Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Jun 2015 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.codeg.cn/tags/quic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>QUIC（Quick UDP Internet Connections）源代码阅读</title>
      <link>http://blog.codeg.cn/2015/06/17/quic-source-code-reading/</link>
      <pubDate>Wed, 17 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/2015/06/17/quic-source-code-reading/</guid>
      <description>类 基础类 base  Pickle：针对二进制数据进行pack和unpack操作 MessagePump：消息泵基类，也就是做消息循环用的 TimeDelta：一个int64整型的封装，单位：微妙  net  IOVector : 对 struct iovec 的封装。提供了 struct iovec 相关的读写操作。 IPEndPoint：代表一个 IP:Port 对 QuicConfig：Quic相关的配置信息类(与加解密不相关) QuicDataReader：对一段内存数据的读取做了封装，比较方便的读取整数、浮点数、字符串等等。 QuicDataWriter：与QuicDataReader相对，能够比较方便的将整数、浮点数、字符串、IOVector等数据写入到一段内存buffer中。 QuicRandom：随机数产生器。 QuicFramerVisitorInterface：关于收到的数据包的处理的函数接口类。 QuicDispatcher::QuicFramerVisitor：从QuicFramerVisitorInterface继承，用于处理QUIC数据包 QuicData：对 &amp;lt;char*,size_t&amp;gt; 这中内存数据的封装。 QuicEncryptedPacket：继承自QuicData，并没有新的接口，只是更明确的表明这是一个Quic加密的报文。 QuicDispatcher：数据包处理类  收到一个数据包会调用 QuicDispatcher::ProcessPacket 进而会调用 QuicFramer::ProcessPacket   QuicTime::Delta：是对 base::TimeDelta 的封装 QuicTime：一个相对的时间点 TimeTicks：滴答时间。  TimeTicks::Now()：返回系统启动到当前时间点的 TimeTicks::UnixEpoch()：返回Unix时间戳   QuicAlarm：定时器的抽象类。 DeleteSessionsAlarm：删除过期session的定时器。 QuicFramer：用于对QUIC数据包的解析和组装。 QuicPacketPublicHeader：Quic Public包头。包括 CID，CID长度, reset标记，version标记, 序列化长度，version等。 QuicPacketHeader：Quic包头。包括 FEC标记、加密算法标记，加密Hash，序列号，是否是FEC_group，FEC_group等。 UDPSocket：UDP socket协议相关类，ReadFrom/SendTo 等等。ReadFrom的最后一个回调函数是会在读取到数据的时候调用。具体调用点为：UDPSocketLibevent::ReadWatcher::OnFileCanReadWithoutBlocking。具体平台的实现类有两个：UDPSocketLibevent/UDPSocketWin UDPServerSocket：从DatagramServerSocket这个接口类继承，并对UDPSocket进行了封装 QuicSimplePerConnectionPacketWriter：与每个连接相关的数据包writer。很多连接可能共享一个QuicServerPacketWriter，因此当需要向某个连接发送数据时，无法区分该连接。这个类实际上就是QuicServerPacketWriter和QuicConnection的一个组合包装。 QuicSimpleServerPacketWriter：用来发送数据的。  相关源文件  quic_flags.h ： 整个项目相关的全局配置信息，是全局变量。   源码阅读 QuicPacketPublicHeader struct QuicPacketPublicHeader { // Universal header.</description>
    </item>
    
    <item>
      <title>QUIC（Quick UDP Internet Connections）协议简要笔记(翻译)</title>
      <link>http://blog.codeg.cn/2015/05/08/quic-protocol/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.codeg.cn/2015/05/08/quic-protocol/</guid>
      <description>概述 动机 支持SPDY协议的动机 目标 我们希望开发出一套传输协议以支持下列目标：
 在今天的因特网上的广泛的部署能力（例如，能够顺利通过中间路由、可以在不修改内核或提升权限的情况下运行在普通用户客户端机器上） 减少因丢包引起的 head-of-line 阻塞 （丢失一个数据包不会对其他的数据流产生影响） 低时延 a. 极大的减少连接启动时延 (通常情况零RTT连接、加密算法协商、初始请求） b. 尝试时延前向纠错编码来减少丢包后重传造成的时延 在时延和效率方面提供对移动端的支持 避免拥塞的支持，跟TCP相比更友好 可媲美TLS的隐私数据保证（不需要按顺序的传输或按顺序的解密） 在服务器端和客户端双方面都能对可靠及安全的资源要求自动伸缩（包括合理的缓冲区管理和帮助，以避免促进放大的 DoS 攻击） 减少带宽消耗和增加通道状态的响应能力（在多路复用的流直接，使用统一的信号信道状态) 在不与其他目标相冲突的情况下减少数据包个数 为多路复用的流支持可靠的传输（可以模拟 TCP 多路复用的流） 在不与其他目标相冲突的情况下，能有效的支持带有demux-mux属性的代理 在不会牺牲我们既定的目标情况下，在任何可能的情况下尽量重用或者进化现有协议  理由和一些启示 摘要：从SPDY得到的经验看，为了不让中间路由设备误解数据包，最好的做法是尽可能的使用加密数据传输。
为什么不使用基于 DTLS 之上的 SCTP 摘要：这个达不到上述3a描述的目标。同时，没有前向纠错功能。
期望的 API 接口元素 API 概念 从最高层来看，我们希望有一种机制能将新来的stream接入到现有的连接中，而不是独立读写不同的连接。
流特性 我们期望不同流将具有不同的传输特性，可以设置或修改应用程序。这些包括等鲜明特征设置： • 可调节冗余级别 （延迟储蓄的贸易带宽） • 可调节优先级别 （仿照 SPDY 不断变化的优先次序计划）
我们期望一些控制通道，可以被看作一个带外流，将始终可用和可用于信号流的其余部分的状态更改。控制信道将可能包括专用帧 （控制帧），作为好保留的流，为加密的谈判。
按顺序的数据传输 必须提供类似 TCP 按顺序的流式传输模型。
###　连接状态
应用程序和实际连接之间分离，使得对连接使用很困难。举个例子，当发送应用程序完成发送功能，它可能试图关闭连接，但数据仍然可能会在本地发送缓冲区中，这样的例子在关闭连接时，可能会导致未定义的行为或终止应用程序。
为了更好地支持应用程序，必须支持下面的特性：
1.RTT (当前平滑估计) 2.数据包大小 （包括所有开销 ； 也不包括开销，只包括有效负载） 3.</description>
    </item>
    
  </channel>
</rss>
